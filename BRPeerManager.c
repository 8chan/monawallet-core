//
//  BRPeerManager.c
//
//  Created by Aaron Voisine on 9/2/15.
//  Copyright (c) 2015 breadwallet LLC.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#include "BRPeerManager.h"
#include "BRBloomFilter.h"
#include "BRSet.h"
#include "BRArray.h"
#include "BRInt.h"
#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>
#include <limits.h>
#include <time.h>
#include <assert.h>
#include <pthread.h>
#include <errno.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PROTOCOL_TIMEOUT      20.0
#define MAX_CONNECT_FAILURES  20 // notify user of network problems after this many connect failures in a row
#define CHECKPOINT_COUNT      (sizeof(checkpoint_array)/sizeof(*checkpoint_array))
#define DNS_SEEDS_COUNT       (sizeof(dns_seeds)/sizeof(*dns_seeds))
#define GENESIS_BLOCK_HASH    (UInt256Reverse(u256_hex_decode(checkpoint_array[0].hash)))
#define PEER_FLAG_SYNCED      0x01
#define PEER_FLAG_NEEDSUPDATE 0x02

#if BITCOIN_TESTNET

static const struct { uint32_t height; const char *hash; uint32_t timestamp; uint32_t target; } checkpoint_array[] = {
    {       0, "a2b106ceba3be0c6d097b2a6a6aacf9d638ba8258ae478158f449c321061e0b2", 1488924140, 0x1e0ffff0 }
};

static const char *dns_seeds[] = {
    "monacoin.org.", "testnet-dnsseed.monacoin.org."
};

#else // main net

// blockchain checkpoints - these are also used as starting points for partial chain downloads, so they need to be at
// difficulty transition boundaries in order to verify the block difficulty at the immediately following transition
static const struct { uint32_t height; const char *hash; uint32_t timestamp; uint32_t target; } checkpoint_array[] = {
    { 0, "ff9f1c0116d19de7c9963845e129f9ed1bfc0b376eb54fd7afa42e0d418c8bb6", 1388479472, 0x1e0ffff0 },
    { 2016, "5a2a587ca66e0500791adf2509f3e6b67f252c9f3d0c56039ce891a53c19c532", 1388536706, 0x1e09778f },
    { 4032, "9cd99bc4fb0f314d6682523259a2e8548951af812eef6a8ccd8c9b3b246b5325", 1388537815, 0x1e009778 },
    { 6048, "529373662384a689510e9789becdf2f207941d6241e28b159e55e1bfa2e7e870", 1388542082, 0x1d097780 },
    { 8064, "f04e4bcf0a137d375634ba5f6bdf65c3a57936543b6d5bcd77aaf2055a153c77", 1388568664, 0x1d009778 },
    { 10080, "410d412124a548e56a673c9247bc886e10b2c43fcfbfcf6397d618d6baa8c275", 1388701498, 0x1c1384d6 },
    { 12096, "397a906acbc377764537b2d2a29798052356e95e92974852fd873fafb6e00d42", 1389110201, 0x1c6c6776 },
    { 14112, "812077f549c0aa6ff4af5268b5368f8eac2afa769525cefcef8a1eb1051ac1da", 1389287561, 0x1c61667e },
    { 16128, "dc5054a419179b7df7a3150b538213d1ed0d95d17d93046fed7e2c9b551485ae", 1389476702, 0x1c5fc9c8 },
    { 18144, "360bf5b7147db2e954ccf4e76408d0b1ee45b7d12f679f9f53e98aebbf268aea", 1389667597, 0x1c647df1 },
    { 20160, "84deef4beace3e6e2ab45d0ccbe09a358f6e43b94cf2301d835ef0e4cd54f16d", 1389880987, 0x1c74a8fd },
    { 22176, "09b4d28644609df046475012ff00f4de3da76c017769b100fbddc7e63ee58ef4", 1390060802, 0x1c70db4b },
    { 24192, "d3f6cb0d42baea65c0edd69053902288d58cd65761128d132daafe9deae83216", 1390258320, 0x1d0085ae },
    { 26208, "5076dafa5ae23ad64815d6dfe7c77fa687f2fb6dc448cbeead1ddbd52e2acf3d", 1390437673, 0x1c7ac8d8 },
    { 28224, "d20d4637dd1a5bce06d96ec131ecd3244b02bd829965ff0675fc9f4ab2fee206", 1390622123, 0x1d008983 },
    { 30240, "1730b369fbe69170d773a022f4aea6ba198bb7913fd39f4fcf6e8c8c8ecaab1a", 1390798789, 0x1c7eb16a },
    { 32256, "ad7a94e9416967a18e03a358dcbbbe4a45758d6c08e5ee3ca8a2693e6382131a", 1390993225, 0x1d009e20 },
    { 34272, "4fbf2d7f758b23df4f4bccd07611d810dcf89857604715e8e685f7c57bd57586", 1391169700, 0x1d008319 },
    { 36288, "6de6501f2578e34a82531b93cb69686d0b25fde7c7ba2454095c331bb0eb5cc2", 1391330320, 0x1c6816d2 },
    { 38304, "0a10464c63bbc23391f9f8bdc240e0e6aa6d4d4c6e00f7ca90912fe2238a6b4c", 1391498644, 0x1c589d79 },
    { 40320, "7c4b3a6a87c21fd0a58213c18d9b5edadc38468e59bb79c15472e7a22ca9869d", 1391642914, 0x1c3abd3f },
    { 42336, "35f8231d43a781930fc0900e9168500490b951b40934d5cd5bfc37951121776c", 1391794920, 0x1c285870 },
    { 44352, "85aefe384845e98d61a59497f89622509d768a7ae86304a571c3a710b57f553d", 1391969031, 0x1c24f4b7 },
    { 46368, "111616cfd785cfe658d964fbff00bf789b88a8adeb34039791d92ab9dc1285d5", 1392150373, 0x1c24b3e9 },
    { 48384, "ec4924459ad0e33e33ed1bc3db793845cd06ce2c67ef10857e71c6bd14f21898", 1392329607, 0x1c2449f1 },
    { 50400, "89da710541e6e214fe7183f2735e32a4ce590dc953f01cdc61444dcdb68a70f4", 1392506124, 0x1c23bdcf },
    { 52416, "6ea4a8034d07bb8ee0046a8987626e17817c9786b33df11c4cfb60ab0e43a58c", 1392691102, 0x1c237528 },
    { 54432, "bd39d144b66c8556f8f456cc6b64745e7251810c25f4e79be74529b3cd54775e", 1392869085, 0x1c23cc59 },
    { 56448, "fba308b3b2858df25e3de1816ecedd4107dd9c9e5b7a39243d16b78061f89a24", 1393036220, 0x1c1bfa7a },
    { 58464, "691e83549714297ba708278375246cc00a81610818b0dcf8cd010877c71c2bb9", 1393221458, 0x1c1deafa },
    { 60480, "b228924c8fc2ecabe259d6f8751c81fd4f467327c3d75683a38a9b54910c263b", 1393401682, 0x1c1cb4d8 },
    { 62496, "dc1d76a734a306e0bfdcb527d8a9f14552dbcb167ee290635c80faa5b14a2099", 1393600147, 0x1c2239ee },
    { 64512, "126612b2f2ade74acd40592565a153c37363ca22bce80efd1b1329e8fddc6a12", 1393773704, 0x1c1f3224 },
    { 66528, "cc4fda5c7bf74485df8a8f780ece63eedbd08db1a378ca3a6d0711d5e87c0195", 1393952284, 0x1c1ef46c },
    { 68544, "b2da6419df706b67efe5e49e3ac32660b0fbd3e31329ad52df84e9cd8f8054ac", 1394135411, 0x1c1df547 },
    { 70560, "8a5f8cf1ac5e7971d0033743b74221dc276501f8e7a1b01c2ff66c094c4a103a", 1394305710, 0x1c1b32ca },
    { 72576, "4e9d800851d50cc2896fc8911407c1000148b1bf68bf2cedc4201f3f71a917bb", 1394488648, 0x1c1c4718 },
    { 74592, "d7dcfd7d0dc88a918c6912b1b50b6e685f1972777438c4f2b66cc31a4b4df890", 1394662231, 0x1c1a61f1 },
    { 76608, "7f4ce8ec864f1926eb6446b88f0bd460361da583932ee90f7dd101d54c52c7de", 1394842273, 0x1c1a1e41 },
    { 78624, "28a870559dcce3afa375548422c5bbe59ead70f21528ecbc3c4395a3bce2e10c", 1395010618, 0x1c160c91 },
    { 80640, "cf20c57e8c262573d8d787e0d5bb02346610d8870e035d431de429b4e4b25571", 1395187018, 0x1c11656b },
    { 82656, "50efd754348b8150736d8d69e0bbd2d615f717356938431fa61c455bdad13665", 1395361332, 0x1c0bfd5a },
    { 84672, "dac6da6157695029f4b20e011df9a136d4faadc29687718a6bfbd619551fea55", 1395546812, 0x1c0d40f9 },
    { 86688, "5cd2d3d55502e108b2b0836772b3bfbae2ffc6c15e2cf0673c11e619f87c4443", 1395727095, 0x1c0d65b4 },
    { 88704, "fa236592d8107208d7f9f63182a30d08d9553394e181150166dafd868c85a999", 1395907072, 0x1c0c0efa },
    { 90720, "e69475dd0f65fc60e35d239b6c3e6bab70bc4c85e28604f08e4573b15e8c6c98", 1396083011, 0x1c0a682e },
    { 92736, "a4d2cad42d26d7e1c5810c6da8eafc8b7af375060c0f5247fc33b3857c7407fa", 1396267269, 0x1c0b4408 },
    { 94752, "f28921bcdcfc198d5477c06103ea2f430c91346dda3d039a5686c4cf8592825d", 1396448838, 0x1c0aa964 },
    { 96768, "5e29f8faa12fb5b07934211d02c94d1897f8b8379af20d04ee0c4f2bd675ef38", 1396629787, 0x1c0aa509 },
    { 98784, "60a8f89503ee90f8df9555644d6213b19a291762187611326dde9ab7e351271b", 1396820107, 0x1c0ce9fc },
    { 100800, "3e3cfc1e6573fe128865c9273bb1126120096afe706da98798be2decc56c276f", 1397003984, 0x1c0da7a6 },
    { 102816, "db6141bde055f7cd269b52a27762cfc92c06ed940014b32b4b6b7015519ec50d", 1397179672, 0x1c0c22d8 },
    { 104832, "950bc97f650bc27168ecd67de535499f089b9c4f26610187b5139bbfa80d1fab", 1397363314, 0x1c0d4e5d },
    { 106848, "af66d7015cfd1ef99f0e84ccf31947b8664aef4626d780f7f602abc5daf84fec", 1397542956, 0x1c0d4b2b },
    { 108864, "d3c6ad41ab00beef9b1f770465b06c53fd9a712d3c8277cdf80dc5dc32610743", 1397726715, 0x1c0cc73f },
    { 110880, "714103b8922831c09b8c3b9fa2227c922a16c63b4cce44c51f4ce25f1864210d", 1397913608, 0x1c0eccee },
    { 112896, "92caa8d05686595cf6dfa705613ee78c7dbb2cfa023e8f602bba3cc786ccc7f4", 1398098754, 0x1c0fd3ae },
    { 114912, "273b5f0a60ef4d42b078f4e171b864851c2f70bc54d8310be149230923af6323", 1398276104, 0x1c0d4a04 },
    { 116928, "741119f36cea556fe3001972c5754779c483de65759f8d8584a9c5aea0bb4c9e", 1398456037, 0x1c0e55e8 },
    { 118944, "f254cdc851d9194a43f042692513b7430505f1bf9b005dbf8c138ce4e40f930d", 1398640317, 0x1c0e7649 },
    { 120960, "53b0f973631883646cba45082dd9df1f7be9a0afa52a9caee625b8940634255e", 1398815958, 0x1c0d7298 },
    { 122976, "4ae0054984f3d8c64888295b837bd66aba359df890448cbecc9384f812f880c8", 1399000531, 0x1c0e0f79 },
    { 124992, "2429d9af2a89a0bc41251c41fdb696f54dd748a47c12224aab1bd2002be9d586", 1399176613, 0x1c0cda15 },
    { 127008, "cd7a0f2fa2e5bc11867730e17d168c275b653b82304087779c781a7916f33777", 1399368624, 0x1c10d371 },
    { 129024, "d5cdae728859592f30a1d3edee73a80001427c68c21ed55cb2cc10bb9a8baa95", 1399543124, 0x1c0dded6 },
    { 131040, "1d05a87f0f7abba62734fadfa4bcc2f06490b1e7ad270ab01e316186a47e3aa3", 1399725474, 0x1c0e3910 },
    { 133056, "a747377c5fa84942f28d875ecf5af0984a962e07ff87f38e04ff07fc92338271", 1399909992, 0x1c0e817a },
    { 135072, "ec534d516ff3a3d414d4e6187cf35fc25d8d5d96206d7d639f948784022fa32b", 1400094494, 0x1c0f1f66 },
    { 137088, "55bd487b8d45ca92d5a3146aa72db7fb1640cacbaae849f35ee30608d10c8581", 1400272472, 0x1c0e71b9 },
    { 139104, "bd2ac08f94762d2b5e328299ed79d11ed00ee9834dac20b5d3b9bc4e6ff60645", 1400449285, 0x1c0ccc75 },
    { 141120, "3d0caa2c607337a610d3bec72a5e4ce6e4fab7bb5948acf873f64559bb9e5c26", 1400638469, 0x1c0f2b61 },
    { 143136, "c18835a83d94b33362d5253a59d24ba391555c6c0becb6d8aa7c9d06268f161d", 1400830081, 0x1c082d0a },
    { 145152, "75200cc78ca216228175e2d1dfbc035d6deb1beb437ff26e7bd0228d0bd3ac20", 1401020097, 0x1c0813bb },
    { 147168, "66bc16c7ba856a3bbbe6c9cd16d8d3eb0595a9268457b7d2c38498d82c44ec8b", 1401211032, 0x1c0d216e },
    { 149184, "502e735bd88bbba8fdb5207f10b96fd78144ab617b9926885f07b9f8cb4cdae7", 1401402047, 0x1c0c085d },
    { 151200, "10efd30d18c14c82cf690ee2333525d122ddb6952c2873bde570d05c7523df2f", 1401591295, 0x1c0e258d },
    { 153216, "b80d1c321827b0619f8736066afeeb43c1b4eac16915f2b63f6f3974d1444c23", 1401782270, 0x1c0bf497 },
    { 155232, "7605a9d8bf5b2b957e39708ef9e1664caaf9c9417a85b285595c586b65a041fc", 1401973204, 0x1c0a6895 },
    { 157248, "126b82fdb94551801a64810fe16086551e91201e32340f95670c33bbff67bbc2", 1402163578, 0x1c09c2d4 },
    { 159264, "55e12b7f5ff43888e8a84593e103fc8cc317a70d5ace0b74f7575fd1b74857c2", 1402354490, 0x1c0cfca8 },
    { 161280, "c0023d8afae4e3714066e7a40731ec7571893ea641662daa98db989e13ff4b02", 1402543914, 0x1c07eb6e },
    { 163296, "5f6d8dab16b378f3b4324c649f1ba739022e8d886157d26e2295d7b76f38e217", 1402737910, 0x1c0c75db },
    { 165312, "54000196354590e7b57a754b2e4846c0c87adf9dd2d459a2bbce430599a986d8", 1402927271, 0x1c0980e1 },
    { 167328, "5a6c9c8e1ac281081f1daadb76af1a6bfed91050fd503ef4244e7d612153d51b", 1403118431, 0x1c0934a9 },
    { 169344, "6189a13d3a59a6b7f1b3630463d27896dd46afd3b1af159ba231e403d96e8546", 1403309900, 0x1c0511e2 },
    { 171360, "6c7610409a17fa419ed1035ca4163ef82ea935c4187a48e534f4d610aa688130", 1403501748, 0x1c0a6603 },
    { 173376, "38b3421d34e96e7d28c2050dd39cfdf952d80b19e8adc4f12b3fca194b7d8415", 1403694509, 0x1c0b2762 },
    { 175392, "8a6f7b9c1079a8567c9764bd015198f4ca458ba05da340c406ac71f2777289c7", 1403884855, 0x1c07991f },
    { 177408, "1b8134cd5cb241a1f6363e51ac43cd500d375a0cee6d1f4e76b6cab666c65023", 1404075117, 0x1c0a2bee },
    { 179424, "ab0cdcd294dcaba6ca1f14223ffb8a169058dbcc2bc02891acdbeea37a92563b", 1404264450, 0x1c053444 },
    { 181440, "f67f0f768b4fe1d2eb3e6c69d78476908c2f27e3c51af56e4adb37dc215f2b7b", 1404456186, 0x1c0736c5 },
    { 183456, "5f647dfffaa42a2236052613383fbd8efd155ea12bfa718f2a0700e8f569236d", 1404647604, 0x1c061f2a },
    { 185472, "4ffa7357f4a02597b1a5a24039f49e52b4b7dab2e8aa87f08f1cca81c16c6bbb", 1404838434, 0x1c031b5b },
    { 187488, "df0a305074125b8db5d2c26c77d83341bd150bee36a17849ad44ec6fdb02c3f8", 1405031053, 0x1c04baa3 },
    { 189504, "82e34cba6be10086a967d2f3ce64f1209f3b83ca19d734a9cacab8881b79e2f1", 1405223694, 0x1c0423fa },
    { 191520, "50e8d892ff17a807c6f88f27cb8931a5a67fc9db483d92dd11b7f199ae1b7ef9", 1405414895, 0x1c02d2d3 },
    { 193536, "4d03ccfb36a41eb369c88a5722f3eb487f57b6c9bd357a6490d7733ff14fb4aa", 1405606500, 0x1c036131 },
    { 195552, "9f363746041e0f9c625339cdc0eedb0fa766d2e9033cf708b52208fa13a01450", 1405796360, 0x1c01dea9 },
    { 197568, "13e006d1fe6d16f6c9dfcbc815ce3b62bb6534815493f2fba55d09a5061e260b", 1405988922, 0x1c020752 },
    { 199584, "04e75668da03730c07e402eef5c8b371f6348e988f269a62578d3a2dcf450da1", 1406181651, 0x1c0224af },
    { 201600, "061b8b99b37e5234a4d32775d74c3a45703e34b89e796eafbcd6ca0804426e7c", 1406373989, 0x1c0125c5 },
    { 203616, "776937491fd1f09c7e37ede659f6890f290a0b43621bd4e03d5c2f929663204b", 1406565340, 0x1c00db88 },
    { 205632, "c2ccc1d5ad10d005f1786313639cbdca66f8148e0998b2baf379f7611aae5da8", 1406757874, 0x1c009653 },
    { 207648, "31e9b6119389df5ad99293d39afaaae62bc8a4d324f93ec99811674d1caa249b", 1406951335, 0x1b3942c0 },
    { 209664, "06b2b56cdab728d42b4c90aba42e801ed681c0ee8467fbb69751b9362171e0ba", 1407149585, 0x1b40ba4c },
    { 211680, "6c9ff57c68f6238e0d7127496e8de9c09fba605a5115b2d4a92250ee91fdfbdc", 1407360157, 0x1b415611 },
    { 213696, "e5e227027aa5275085fe60caf19b817e0861a2501e92b9a640d4f34074e17987", 1407572155, 0x1b3cc7d0 },
    { 215712, "aca5b67114d9a932735932ab6e6c189f5a83bc7541602a52082112735b0c54fe", 1407804247, 0x1b3f2d18 },
    { 217728, "ad8dd158bf6f8c8bf71d2c2db95f9953ea3e143c126f6637b42bda5ec19278e3", 1408027472, 0x1b724b32 },
    { 219744, "5f3044366dc77f6e3fd7a34f89ecb05c3ae13ae72591f0c3c2c4a4302623efa9", 1408253626, 0x1b6218b9 },
    { 221760, "fc5117f359f582f29f013c0041fe2c7e5654969d187a91ae2a8036e29573c75a", 1408482602, 0x1b4587d8 },
    { 223776, "0bab513d306c223492e7713ac877f0b822a0c8a91c728466621d792cb38a96aa", 1408717584, 0x1b4e5f57 },
    { 225792, "293ca6376396a1a82080bb1692501c74267a4977f37bad73d907dd3cdec5c8af", 1408946167, 0x1b4fbe5c },
    { 227808, "9fdbf86b303bc01778230ff23d0c88b0098306d4527ac4745305f06b4707e99a", 1409165243, 0x1b51f8ad },
    { 229824, "6d3c851528fea247196ec67729a7f26a9a2401e55a42e1cbeec4c6346320cb1d", 1409390385, 0x1b3dff1a },
    { 231840, "cfe40712522269c362f004677efdd5619c7ae0fac32231d2258d955c8220448e", 1409636599, 0x1b4565a9 },
    { 233856, "64cc22b266268a00d8a6c191155098f0ec0866ff419baf17f6d2d01d3604f184", 1409864037, 0x1b486b65 },
    { 235872, "5fefad7493a06db3ee87046bb6636aaa5fb5f7205dd167e76f8b8fec1a334388", 1410105774, 0x1b58167d },
    { 237888, "b5493e632fc3a2653d72cd852ada4f349f7c76e42e00541134e267f0bf5732e4", 1410363251, 0x1b7039fc },
    { 239904, "28c9641d5616d097487cf6e87d09b3d196bd0d9b294ad63185eef8d5538c71b6", 1410607435, 0x1c00966f },
    { 241920, "ee306f11e42ab6add9dedd7509d46521eb97504a2122f7bb253a3f7d5b7a6304", 1410888885, 0x1b72c206 },
    { 243936, "971009296c57364853d50676cdf7bc0a5b9ca5c06048126427d81451f4d92c4a", 1411199624, 0x1b4eb27f },
    { 245952, "b831ae78251b2708aefd5d390aaa009a9db3ca2f6ac4d921dbddd577d3e3f423", 1411490765, 0x1b5de2f8 },
    { 247968, "8fd1ce26aa5521035aced4898514bcd11deffced770a98af6be83cd7fe0a3436", 1411760566, 0x1b551050 },
    { 249984, "17ba780b7f41b517eb5775d548a096a32724b41478077126bb5fa2095e2266c5", 1412054332, 0x1b60bb2d },
    { 252000, "bc531405faaca02a5dfa5be0cd1e98e0c1850bd2bf4069f6196014fff1b96dcd", 1412302680, 0x1c0095da },
    { 254016, "3e47a017727a807cddd1443d630cd7f668fcd0e83669c68558df317ba553d5a7", 1412545207, 0x1b609a82 },
    { 256032, "7ebb4af72229a1007ebf4b78d1082b16b3c027dd8e164db3367a50485c9df9a2", 1412805612, 0x1b7440e3 },
    { 258048, "5fdb17d13322758d7cad3e7fa110a6e18dd2d684d2d0613b80d75ca045f10665", 1413078398, 0x1b7b5cd5 },
    { 260064, "e5c18545269617346261a53fff87e19e228b3bb249caafe2b0476fc0814ca05d", 1413351293, 0x1c008c70 },
    { 262080, "8090cf6d15c18941108f001e4b7526f3db92df4c0e86b2de2e74e20567c045c3", 1413610113, 0x1c0092a0 },
    { 264096, "e615873f78af6fa0deef8b2aa05a680bd778427d4cc11500247c1e9fc7ebf664", 1413857015, 0x1c00b73c },
    { 266112, "763ec7ad42ce2d720a581ed0c0f5bafd34aa4b8b488b7839a3b4532628355ab8", 1414106292, 0x1c009753 },
    { 268128, "de401b94e231b1d6f8403fbd20c116d92068b072f7e1a581587f8f2f1ac8ecd7", 1414352186, 0x1c008d86 },
    { 270144, "3aec7f51c69486cd725757ba0079c238aada8fd036331cb123d5104a6506c72a", 1414597839, 0x1c00cba9 },
    { 272160, "9843e7aa52bfc5f30ed9671f98649dcac44bc2498045b6c349bd4d3aa1b7185c", 1414829009, 0x1c00bf31 },
    { 274176, "af3e0d9eebc3512448181f61b1c3dd7f93315048c3a9f3de4389ae2a629fa5f6", 1415081054, 0x1c008709 },
    { 276192, "e419c0896c079bf10f24d14111846ad95ebe6a2f49eba9f4efd6c41953726f3a", 1415335348, 0x1b6f6fe6 },
    { 278208, "6279e15e657234a5eaf67f871ad5899517d08f11c6127db8740cb17338ecd896", 1415600940, 0x1b6e2fa6 },
    { 280224, "3a616678ddc22a27a7a0b2c3d8276e352f2abb3af28f8e4266024d208dae5c2a", 1415867504, 0x1b797c66 },
    { 282240, "0f3244adc8518e9c53cd7dc0db72301bcdfbe47b0ab42d751e8b1a70e2101446", 1416121884, 0x1b677e65 },
    { 284256, "17fe52099b49185eeee2b1b6a414f0f944affa4dbe1f912d3c68973999617f5b", 1416386470, 0x1b6938e3 },
    { 286272, "bbe6f5cd145a07737a9bba49bba9c44f75a94a725e0f32e1c346b7fbbfe31c77", 1416661294, 0x1b5e6c8e },
    { 288288, "17ca1bf4e7d193614bb4e5edd4eca60b52668f38152a54676b081f047f30a868", 1416941310, 0x1c008751 },
    { 290304, "752f0fd3206290621e752d1d44987058c311b15d8ad25fb0340a17e0f9c70bac", 1417233758, 0x1b5dff78 },
    { 292320, "bb1f407c593b0356b3995d22a84c73d4ebe191d653705800243475fa8c185515", 1417521646, 0x1b7ce0e2 },
    { 294336, "fdc49e3e969d91ffef28ef6b10e7395cddec5240c2533768900154b670d794da", 1417790068, 0x1b62bc9f },
    { 296352, "253de119011ed8f85529d35012d27c1e7fb4c005381456db80a35cd216796063", 1418042785, 0x1c00bb7a },
    { 298368, "4a7d6aeccf261d0965fa2102aaad6ba5c2f44154f042e3b995c945742547697c", 1418305078, 0x1c008300 },
    { 300384, "98cb7a1dd2ab1263abd3294bf7870263f44e47b82ec69a1eb34fc3184ca477c3", 1418577975, 0x1b64dd7b },
    { 302400, "ffff3d65d170d8a515d77a0439dee9f6a969097f82b6061f8e1a2cd9a9ef6024", 1418879501, 0x1c008127 },
    { 304416, "7857aac1617645c342373e9c4c3d2cedd4389883212c1b899e5e8cb7a2ae93ed", 1419191308, 0x1b751499 },
    { 306432, "f6ea1c63149bb4b9459c3fb7187728ca36a60976200bf563ee21eb6c5661de54", 1419526700, 0x1c00b1c4 },
    { 308448, "82584907f72d616464853ff50a119cc95881208855cc246bd7cf72529cec72c1", 1419866305, 0x1c009b4c },
    { 310464, "a7d7c66244cec2ed358ca13e3a8fb211fdc9ff2b24805998bc7168c2dec23805", 1420194498, 0x1b6bcbba },
    { 312480, "507daddce06b9333ef6c93cf32af37388125b5b5964aca46f2eb42f254b6eb16", 1420602189, 0x1b7065d1 },
    { 314496, "e5455c29bd15fc4db72f553fc3d124979853954fbebf503962dced34ab4ca754", 1420972088, 0x1c009a6c },
    { 316512, "82ba5c45cdbc65540e10137d93c14eac18da0b552a96bb31a85b67d92d79b5cf", 1421361193, 0x1b5505c6 },
    { 318528, "8b3619364f3397ad5ca8b18a2b2705cfe4ccf81bb58abe64c44e3948220a7493", 1421770444, 0x1b49795b },
    { 320544, "0412c8200a6752533d21a60d2296c268b3767c7020da399d980abfacc2b117c4", 1422250694, 0x1b71af94 },
    { 322560, "27164ef84d2b4825999f05f536a63f6d74b226960ce5d5dda885453209ebe90a", 1422618051, 0x1b43a0f0 },
    { 324576, "07d471577f08ca14a9193be9f86bed7614a10dfcd616693e76d7e539fb6349ea", 1422921588, 0x1b71e5ba },
    { 326592, "3c2144670b8b55189d3ab8a8fd6508bd1a829fb4b881462232f24e3a5b485326", 1423247486, 0x1b3ea2bd },
    { 328608, "3cf8ca1e52dc153704e2461e1cd1d3f61ada123c61f2eb92d755d6c626fe0682", 1423611479, 0x1b2941d0 },
    { 330624, "3c21d78ba2a556bcd64fe2f087dc4c0f73392ad99d7e3b7b899587694d952e7b", 1423940877, 0x1b37f3eb },
    { 332640, "95bda4562001ef0f929019982d833d1cedb06fe04c9d252caea7727f1f13101d", 1424248150, 0x1b3b58f9 },
    { 334656, "07e904b40c04e8b8fb65575ceaf47957d8c5d4c6f1de400c21e559e5563d7822", 1424540760, 0x1b4781e3 },
    { 336672, "51622c038f6d06f189115477393f56a4f3cf6f68daf4aed5f6b026366ac2ce98", 1424790373, 0x1b2f2768 },
    { 338688, "3e28775cc04ab84181ab44ed0b2afdf32a96c748268ab46ab99e1bc98fb2e29d", 1425055393, 0x1b2a0c06 },
    { 340704, "590aa6b20694987eec5d10dd3514e011260ad81aa78b129358773f5f26892675", 1425322282, 0x1b17ab8f },
    { 342720, "f676d960e85a5e84bf3693ba7c48fbb0247e84e7efee4572212c96ce39ec3d84", 1425576438, 0x1b11c353 },
    { 344736, "fe1dce3605c23eec930ce30c046be130aa6f1f217117ceef7e4740e6799b20fe", 1425829425, 0x1b20b43e },
    { 346752, "a888915e3b9063d273f9c774e52322b1de22de4764c350ed3ec53032d7127e7d", 1426123948, 0x1b270eda },
    { 348768, "c2d1b9e5ef01683a95d99197c810154cd0d3b2262152947fcee15bee8dcbf888", 1426387935, 0x1b15f642 },
    { 350784, "9289031a57043a532702ce0b0c871f8f5d7109ae8ed553c35176b547471ade29", 1426623349, 0x1b23ab6a },
    { 352800, "50fbd6679c8322fd7e1d7d82083122f4f24477b4d602883b635c49594181cb49", 1426841097, 0x1b203bcb },
    { 354816, "c911377585844be01845ddd14757e50891ca99e824576ceb0d30b28fb3ef6b24", 1427064718, 0x1b1ac6ce },
    { 356832, "f30bb4dcec0295aaab1aa2fd032461b9bc4265c337ed4879a25f8b9e9a2dcce6", 1427277526, 0x1b148dc6 },
    { 358848, "4c78c149b1062017ae06cebcb9c7d3fe13324a5d7388441c8227374299febc4d", 1427503640, 0x1b16ea53 },
    { 360864, "08ddb52be41d0ab465548ddf52de91464bee5b9cbbd3d359a9f6201742ff53e5", 1427729591, 0x1b1d16b8 },
    { 362880, "a7d66d2906491e5452929efb9cbe330032073f7535d43c58f4e469d6aa53eb48", 1427940543, 0x1b24ef3b },
    { 364896, "115b632f957859833401b7f13c814354de00895db07f5a3d53f62d936566b799", 1428225223, 0x1b13dc3b },
    { 366912, "5a0835a525c8189bc3370cae39dbb01aa861ff669069f31057090969c1f25561", 1428479759, 0x1b16f5ae },
    { 368928, "a8ed1d7c6bd14177205cf2b4393f4b6d52716f7da796547aee612fd59f56c370", 1428729923, 0x1b0b593e },
    { 370944, "f487e62f654dd447c48722d33431c8bdb6fcfd58ffebefc90ebd250e284cc1d9", 1428961207, 0x1b28176d },
    { 372960, "1c40106fda15f92abdef6fff09dd13e88b16ce7e504b09efaffb200030d34989", 1429177926, 0x1b1fd8b2 },
    { 374976, "9ce6595c48cb6185e1a356ff1c6a3db2d01e78e58e76ca4b543bbf008f4a5a65", 1429391060, 0x1b22bcf3 },
    { 376992, "79a15bc474b6d9262019564405efd91c36e8dc5ec6cbaba7b277711ded3632bb", 1429642578, 0x1b22f07e },
    { 379008, "72c9f16dfea2f4a24ddbd1e7f7dda38ea0d96357bf802b8eecbf45a3133453af", 1429877912, 0x1b21a637 },
    { 381024, "83b1a596406e4df8c1fd84dded92f90a7c300d377b7e84e0b41fc0c86fc3b4ef", 1430109710, 0x1b1aa9fc },
    { 383040, "fc80552105d6555a1c7be6b0ad42b142942879c75d4e917609801cba95ba1588", 1430358024, 0x1b1eafc7 },
    { 385056, "c0517d9a301ade9778dccea2d050e843498627b444d7de79eedc771e43a96e1f", 1430600052, 0x1b26f2f6 },
    { 387072, "5193a8152781f4e379621356bb783413513313421c0301efa9cf979f25b7621a", 1430853828, 0x1b25ec5e },
    { 389088, "450265f3adedd720cc76df7b621667e250369b9e1cbe6913086495d3604b031e", 1431092804, 0x1b19af24 },
    { 391104, "ffcdcf4a99377d10233a52d5a446cd7987bcc81bc44a2ff582e202d1aa2705f7", 1431380771, 0x1b26ad96 },
    { 393120, "3812e05c6a72ee6189f50bfb2d7fe94ca9183f66ca8b74c9f2dcaca67eefbcc8", 1431690843, 0x1b18db67 },
    { 395136, "0a3c8dbb84c68f0d32ef717c6b6066a71b95da4a70a2c0b0630a54363fe36539", 1431945581, 0x1b139d44 },
    { 397152, "0b22e03856025f3d22675ca5850bfaa82b4cf28aed339776d32385b2a393433d", 1432304949, 0x1b1c66de },
    { 399168, "120ec80426090480cd1d7f6783bcaae19a1ca6896b92bfb0cb9231b9de59998e", 1432742113, 0x1b18af62 },
    { 401184, "f7231b76cdcc230e1f51577d0dd70551fc8292172600f7794ad8c1d36f911585", 1433153359, 0x1b1d9ec4 },
    { 403200, "67c31a52f881d020dcaf3ab14e027f4d0710a16263502611d8688d8b86ae9e2a", 1433578614, 0x1b26ac5d },
    { 405216, "9ba4acfd98e91faad17156fef21e797ccc38e3243cf3f969832bb332b2c12501", 1433952816, 0x1b1eebe7 },
    { 407232, "55592c0acda4f9d34373c89ace9292b8d39488713383db513f9ebcd020a640a1", 1434298964, 0x1b1730d1 },
    { 409248, "5e9d719a930c7a8de9461f5e73aa526db1cf4e9b47ad3dbeef5fe16ec99364c8", 1434564788, 0x1b2277a7 },
    { 411264, "9d5b556fc89974907def50ccbdd6db92b0e0afc51ee81aa8c5b235671a33509d", 1434810267, 0x1b214f5a },
    { 413280, "00790e78f14c92b6f88a7e2b38057493f8932f3f8cd9b7170528a7c95340b4b3", 1435045323, 0x1b2e1a45 },
    { 415296, "842e4353906c0305b46e6d37b26ea1ab79c570f54b14d864fa8a958876f608e8", 1435311287, 0x1b1ba2e5 },
    { 417312, "52064cbd007a6b83c0f3e0cd170e6f7f329ebfbdc9edaa160e5e625c15b3efe8", 1435575972, 0x1b25bd70 },
    { 419328, "5297b4bad60c9961728305d9b6f24a668368cb2f3852bccb2cf2f76b5747705c", 1435914641, 0x1b4598bb },
    { 421344, "eab758f27049fb50dc60a0325d26ca02a73cedd02f1e184f698bb79a1d2de22c", 1436250385, 0x1b32c27b },
    { 423360, "0f400afbe27e4a14f8e597fade2ae093bc72aa544185658f57ea404d7fdea415", 1436640771, 0x1b2b5177 },
    { 425376, "709b93efedb8ad332524ba503f386bb728ba9e2880617ed62dfd08baff440ac8", 1437089810, 0x1b2a2e9e },
    { 427392, "d044407eff9b5628d7ad191d547246d9e748f6a5342a5debe7d30fabf1943f4b", 1437481153, 0x1b3e191e },
    { 429408, "77b42e6f904fbc95f5ef105b30179a6a4f74099264c6a2eb4c6805a2c8775799", 1437889500, 0x1b326a96 },
    { 431424, "9b00c5957b4953b852a5cf2a91a5cbaf9823ac8215369e2be9aadeb6cef290fe", 1438270683, 0x1b321247 },
    { 433440, "804d2284a17dcb1d295b35412e4832cf2da7ab7e37085aab41c03a5868e7b5c3", 1438733480, 0x1b2d447d },
    { 435456, "ef70773d6ae41fb658b712a52d70588d879252d4eab051c48ad0c679c9a040a0", 1439234436, 0x1b342b1a },
    { 437472, "abeea3fc03f7aba7ebdee0f243c174ab9093f87d483211c35e12c23124a84e98", 1439634014, 0x1b398629 },
    { 439488, "8bd4546b5874db6f62c3338a55a1eaeafd2e7f9d5434b9de704fcc39e9df482e", 1440071086, 0x1b3bbaf6 },
    { 441504, "6c5f2681a21421b02a2ebe65775931775adfbbc467a6e37938f4ea5c0415b83c", 1440605784, 0x1b1255a5 },
    { 443520, "7f97b54c3d57aeab040d9eb8a2892a74fb944a5bf762fdefc4cd0835007b8101", 1441219824, 0x1b1958c3 },
    { 445536, "b7a09398f7e666b83e1d5ab28364d01829c362c6739224714e578e8babede4b3", 1441851003, 0x1b141bda },
    { 447552, "e5cfe26bc0f22f97b24169a1c47fa44ad7b34c867e947b2e3f3c979c9dfa48ad", 1442494523, 0x1b1d7a0c },
    { 449568, "8b3009ed2fd07310023f17e3849a6f0aad6fe81105decca8176f6b4dc10ea172", 1443230145, 0x1b145c09 },
    { 451584, "61f14ec93a4ac7f6cd53377693715d3a97e6a15e6ca5be8d98b5116f74b0f607", 1443485113, 0x1b6c4954 },
    { 453600, "dfc5fd49479cce1056b9c9d8c3757a33adb1868bd3a6bafe7906ee75c1140b8a", 1443675488, 0x1b7727f8 },
    { 455616, "58ae10a54aa01b1be9e122cad19c00ca7085e766f553ad00e04f6abbe360be44", 1443866644, 0x1c009a36 },
    { 457632, "9c2b0733f4d0accc3732b428acea75ae1e0e793e869d1ab316104194cef032c2", 1444056585, 0x1b562d6e },
    { 459648, "7f588ed974b18186e897ec1988773d4056ba3bea6ee091edd962ad337343b635", 1444248662, 0x1c008b95 },
    { 461664, "ce05571a37141b6034f409c73ab09bd6e1f453315c68426ac2a02b4f5d9c8bbc", 1444439545, 0x1c009712 },
    { 463680, "9771e55dddd76a05b58fdde6e24da36fdb5a2b5566cae5393485dc32137323d4", 1444630068, 0x1b7fc52e },
    { 465696, "78491abc4a877c6fca1c52a9ca4da6e9b622180a5ddd51b68692bc7b770a4c25", 1444820551, 0x1b62bc4f },
    { 467712, "b681c3181bf6d265bb030b13d79414d2b011f7defa5f96bf93d288bcf3d79755", 1445011173, 0x1b6077ea },
    { 469728, "89c01311b0e57eabbfa016c47773d277072ff44a1b45995e3e8c2016a8c71c71", 1445202350, 0x1b68f64b },
    { 471744, "5c854044606dade84d318022d755e749a669a687b65baebf25923d3683ab7176", 1445393008, 0x1b48bd63 },
    { 473760, "a240d325752edfe2ca510916ccb19cec52877bab0224268b537d18711976cf5b", 1445583613, 0x1b6c9b3a },
    { 475776, "7d733e90dafc0163148eafd4ec9b07da85335f812b41dd3f34b24e6a1c103734", 1445773975, 0x1b460503 },
    { 477792, "ba4d11dcd28f18e41c0e62c1d24273f5e120ffc583a22879a8d6894b7d7b5805", 1445964681, 0x1b4973e5 },
    { 479808, "9e6976cf784a9d2b74bccdcd8cc8acd65fb6bb3e04d4ed4d638d58c440477f17", 1446156074, 0x1b4ea044 },
    { 481824, "f08923ec9591ca7329ce9bb0f698768cf0a650e9bdff78479085c3fcad737425", 1446346909, 0x1b5e5f43 },
    { 483840, "33a5398463f2ca179159f4a7de022609f55c8e78bc625c38a30067d615bb1dfc", 1446537758, 0x1b5cdaa2 },
    { 485856, "159ab8fb1d397c1817c6505a8ad231bb940989a3560e10470ca94f7889db7228", 1446728470, 0x1b7eb75f },
    { 487872, "e69d80138025af6fd053c20e96559265ec9eaf3690ff0b3397782de2e790edcb", 1446919057, 0x1b514b91 },
    { 489888, "b2809facf4bce55b44bc651a3bcb297885bf5e1f68ad0c9d2a9cb549d9cb1672", 1447110561, 0x1b6c4881 },
    { 491904, "49a397e0c9a4ef4827b6302f0d63dedcffc6905aeb8c2b42c2c9b787f5c8436f", 1447300377, 0x1b518672 },
    { 493920, "bf6633157fecac994ea99edc6d6000cd7368af464ebecefe10a3a8908e24ac9d", 1447491153, 0x1b4e7011 },
    { 495936, "60134431846ebbbf8d45d571de162de80355c1354a2a66a57fda786162960493", 1447681443, 0x1b4efc7d },
    { 497952, "2650256ec4c70428894c246aadf88fa25b1983c2fd1f89f670049b4eb6a58ee2", 1447872392, 0x1b4fcf02 },
    { 499968, "bf8f69a9bda8f50a849ab3ed2253a8a2871df7e79a2f752827ed50d78462a4e8", 1448062173, 0x1b387968 },
    { 501984, "90f0d9b6b851912263e85dbe42d6f02a980526cdc4d265e9d284e779209bda5d", 1448252990, 0x1b3f6df5 },
    { 504000, "e3d813e519a79b8bc4d7b35bb923c9992dc4c0bcca8d07d23ae9c10660d52408", 1448443781, 0x1b5e2d4d },
    { 506016, "bbda999dd9feb682df1db3e47ed0673438f5b168daacfc09d4da2b0acabe4e85", 1448633839, 0x1b5a4c8d },
    { 508032, "49f380c65394ff0b7ee67a49703d9c04947c36aa52249afc5da5b5c179ffa8b3", 1448823891, 0x1b44bbf0 },
    { 510048, "5dbb6ba3d97a425223c3fa119c49329858d7639fac14f8d4aac9ac3a970830f5", 1449014574, 0x1b45d0a1 },
    { 512064, "25d774fee69cd76072cd78ebd6d66be25f77702137fb35634a04a3cb0ee559c7", 1449205165, 0x1b4ecb7c },
    { 514080, "0b403115e1b8c32972e8d374c94079fe01ca971da37eb02ec8ae8d277ee20f50", 1449395281, 0x1b449182 },
    { 516096, "c0c3f658e45090989fe47c5249de9edcb173433a20b603a5158f691bdbd0f23c", 1449585569, 0x1b5c1cf8 },
    { 518112, "e7bd490bb2b796ad58ebedaec27c569fbd137d130c24037f387d493c7d0082ee", 1449776053, 0x1b51309e },
    { 520128, "e056eeb5ad57e8a22da5d3c838cd5c6465bc9aa290a98a37fb1fc5204415ab47", 1449966285, 0x1b492f95 },
    { 522144, "815da06b3c0b5e974b66011d87a7c466b705231f0f6f8c443d7470d404420e97", 1450156561, 0x1b458bbc },
    { 524160, "91fa8b419207bd36d87281aa0835b73163689c5fd891c55ba0131a02be39db1c", 1450346487, 0x1b4160f7 },
    { 526176, "7811cf16f64a0f52104c6ad3414c1317aa899692a3c47a15491768b7966da0a0", 1450536808, 0x1b4688d1 },
    { 528192, "874e0b99f78ab8b58fdc18ce0d3ca721151025856e6fd661f3134463abdade99", 1450726686, 0x1b4b39c1 },
    { 530208, "7f31724f28b55de1f3030d6ab32499ac13ca1f03b61dddf1bbe83bb275ec2573", 1450916709, 0x1b32033d },
    { 532224, "60c5fea39034012b01a7dfbaea0b9d8fd5d5b29455b551981ff7b7aa0ab0ecd7", 1451107712, 0x1b553c2b },
    { 534240, "d2c68f6ef19d5b6b0861227525cd98e116ebd80f21d4dcaa7471b6cd7e85c720", 1451297620, 0x1b537c5d },
    { 536256, "bc17532304b48af300c550335cbcbeba3eb534bc23f3aab72a83fe4fc277a1e5", 1451487487, 0x1b34dc16 },
    { 538272, "20fd56fb106786fd598f3013f89b7511fb8bc0e23eaefac13722ca48ff5aef14", 1451677324, 0x1b3ff54e },
    { 540288, "1ecb6b8f7a4f0c8967b2197f7ec1bbe59303da422986808fb40b6b26d8e66cc5", 1451867655, 0x1b425cd6 },
    { 542304, "a05b43fbd4992084657f40c23f01d55bc9180b478c163fdee774bb8341366799", 1452057501, 0x1b3d2deb },
    { 544320, "f11827b1990742e0399bd1f94733cd4045d45ce4bae9bddb685464ae2158de7c", 1452247924, 0x1b3e2602 },
    { 546336, "6e7fbe706437f45877419980d44bd44a4a98ed82b9974c3986c8b9d6858ad54b", 1452437865, 0x1b3a8ef7 },
    { 548352, "5693d78dce3a5433431491fa50a8668ae8e6dd1aa2097df417e7351a60c3c446", 1452629024, 0x1b5587b8 },
    { 550368, "21b120137398fd7309ffe403b9f9019bbf7fe8975393eea233e512be6b0f6480", 1452819317, 0x1b602e36 },
    { 552384, "5902ab9da6f849d966ead5ab772ee819fd362a0b83514062895948ed79ecd812", 1453009355, 0x1b4fef35 },
    { 554400, "b4d1e846a4f5fa96f6fb4bc6cbd220527085b44c127e2d2cf06da51d8da0d7dd", 1453199310, 0x1b490c7c },
    { 556416, "27d1b12b5ffa1c5cfe33e0f5e630b03f84c03f1f85684b5ad2bc3573b5faec02", 1453389403, 0x1b3ebe6e },
    { 558432, "5ab42e4c99a4d194fe7942b0147d99620bdd4d60202eb56131b5273400ee872c", 1453579754, 0x1b558b94 },
    { 560448, "e501a362dfd7738b7acffa1afbb7147a71ae02dea7d433ddd640697d531df22a", 1453769847, 0x1b4a6c18 },
    { 562464, "e8e640d4a5cfa1f91516550b4415479718e8ca695422af93f6a397635007b6d7", 1453960791, 0x1c008b86 },
    { 564480, "8d0af24450a1cd65f8ac8b7f96af3e77976131fc0386ef17c5fa1d99ca9ed967", 1454150556, 0x1b550122 },
    { 566496, "2020ea174a1dae922a1659910284c3fd700b4534b4a24d2165050c774c2ce2cd", 1454340716, 0x1b531b50 },
    { 568512, "d648be6baa339283d3eef810c1992071600cce0b6ffecf73b2cee7f54ee1daa3", 1454530523, 0x1b481684 },
    { 570528, "c70174eb15cfa42cbdd72651904fcdd4266324718cd2590ba8598d0ec5f2ef26", 1454721157, 0x1b5ca041 },
    { 572544, "8810649b5b4eddf7d6db81aa01a0c7003f9fc90d76c4225277d4061db8a5fea9", 1454911235, 0x1b6efc5d },
    { 574560, "e894c8e077dd2bf0c6fce91aeaf93a1fca5bad27145e312c2a0128e1edf5d4a9", 1455101259, 0x1b5c7f24 },
    { 576576, "f1f63ca4e96b5d129283013d9eb893130e658ba91c48b54ed58e0f6a0ffff27b", 1455291405, 0x1b6efc5d },
    { 578592, "14f1e0dffcb0cbc5c27ed85bbfe6a3638d282c3c93c748e0191bb8bcd401209d", 1455481740, 0x1c009101 },
    { 580608, "99d7cda24aae37d787482438b838aaf5630429e5dfed0d945aa8f08a2c86ddd1", 1455672088, 0x1c009863 },
    { 582624, "efc88f45f639cff3dcfab79cff19a9c5de91b913273510f45b0657b9d82fb99d", 1455862049, 0x1b7f7d65 },
    { 584640, "92a8e90683177d79a7a7f2191718ca52811308e06c9f432d939d411d5730d25f", 1456052596, 0x1c010d76 },
    { 586656, "8d157670e0c44150277cde29aa5cd237fa490196feba075beafd7d6daca3acaf", 1456242612, 0x1b7edecd },
    { 588672, "1570abb7b5e4d9536f77f87959f697d4f409db45e4bd369d29713fcfbdaab338", 1456432505, 0x1c008412 },
    { 590688, "58ea380a1201ccb6f39cc26b8e8c029332fde68716f3a19511b8b7d194d37a2d", 1456622952, 0x1c00c6d8 },
    { 592704, "0e116cfcbd042ec106ca207bd5a7c87886066b70bf1fc3f7ef35a32f7f916f1e", 1456813526, 0x1c00a0cb },
    { 594720, "f928c2ac547836f9880b47c300d936e76ab385f08a0572c5a8d94a6d47c507b4", 1457004389, 0x1c00a55b },
    { 596736, "6d961921ae5f9fefa10f81b402858cd8fb07308f3e87d6bae1507e3df06e09f9", 1457194148, 0x1c0082ae },
    { 598752, "7ee9b19d9fd0b9bcfbefd26d8b66e02c159c1485ca7919b408652a24fff77374", 1457384592, 0x1b711a36 },
    { 600768, "87a59ef623491ebb81c4db66a24ad79c5e6598c42fa61ed8d9bf008b10a1e593", 1457575334, 0x1c00ceb6 },
    { 602784, "964374954abc61dd4b736fcb13884c391f070656bfcf6ab96fc4fb59dfe9cf4c", 1457765658, 0x1c00d2c0 },
    { 604800, "02d0510ca18d081b67df44a3f4798c55597a25ce9bba442de825068e0cbd81ad", 1457956652, 0x1c00f8f3 },
    { 606816, "5ba540cf538ee878fd0b621f82369eab636f2f2c4bdc11e926f43ec0eaef1dc5", 1458146577, 0x1c00ccb5 },
    { 608832, "65194b40d2082703f91e714a44c56734dc800cf7c0abc0ab23528240b5213e79", 1458337203, 0x1c00e2fc },
    { 610848, "7f1d92d97f10acb1d73c2a80122775a36d765779a5d86214ff7a6b9124bd6e61", 1458527582, 0x1c00fd2a },
    { 612864, "86403af9ec0e101a555b09c3f84e30a2875264378a58553d684b11b73ae16e5c", 1458717438, 0x1c011c6a },
    { 614880, "33a2d120faae3ae65e5cd90a4aa8cbd288a634f5921d57f708b7c0f90c08d286", 1458907933, 0x1c00ce07 },
    { 616896, "fa5f8a49c7844fdd23d75800b28e57171a208c573defd2841cd199359d00fd6a", 1459097886, 0x1c00f664 },
    { 618912, "172e358632869f7b8255fbb690fa0c32e73a83fdbf47194123e3814157b319f1", 1459288057, 0x1c01354e },
    { 620928, "c65158d43f6e584b4096a0f9afaad63a50085e135da72f853cf9ce602d94f2ac", 1459478059, 0x1c00f93f },
    { 622944, "bf6c52b3372074b4382a60adead47229369d37dd073b34518182282e7f7ddb5a", 1459668036, 0x1c00e792 },
    { 624960, "e0ef3922bb6fde76839b9d56e842480924cf93ac67d62bb5921a19a441c13c95", 1459857960, 0x1c00c06d },
    { 626976, "8b9dffeaa908064ce780bd0db3bc841dbfa9b59e9ff0e27b07fdb12d1f1bfdff", 1460048089, 0x1c00eb35 },
    { 628992, "68c00c1156e7b1afe5a6736764f10cf1c3a48b4d19717c3e9a5ef4377d6f1d0f", 1460237984, 0x1c00b159 },
    { 631008, "2538cb8bfc5db5608a868c6cb511ed52e7f78fc74210b3f2b79a9165baf8df11", 1460428370, 0x1c008d56 },
    { 633024, "1db4fa6e1f7d365f295ebff104c300d89a5e482b47e2e6d1d9226794148d8430", 1460618133, 0x1c00b6d0 },
    { 635040, "c5eca932546b1b1ede21303b8a2deb18d06081c25f186e1052e848b29411fa2f", 1460808104, 0x1c00858c },
    { 637056, "605bb83d93dda9783e770d4c42d47d281553602572fbce237c2d652f3de33f24", 1460998470, 0x1c00b2a1 },
    { 639072, "8fd298e4747e663a3c5151225b371485111c13b6303922af199a2761b07019a5", 1461188437, 0x1c00ab0d },
    { 641088, "07447c14fcf3be0b91f806ab45764bf3e100ccce2f469e5d44593e45918bfe30", 1461378688, 0x1c008be7 },
    { 643104, "10f54bbc46bb30a55027ec2b3e8a22fce56debe01cbb5c536e2d036123724903", 1461568726, 0x1c00b0af },
    { 645120, "8021c0480e382177e3d82b68a6746ea56237dbb7951f34e70df9efedf0076e3e", 1461758514, 0x1b7e0765 },
    { 647136, "2bda2646e43ae60fb83afc640bb29d242fb06f38e9f2db70022d67c4ca7bf6df", 1461948894, 0x1c0084c5 },
    { 649152, "ead46b4bcde4843c58744a1b0fd9ea5b53055753f39b7381e935d56f07508ceb", 1462139369, 0x1c008d55 },
    { 651168, "34ec732dd7af2fa9f1cfec3624626b246c415f43784060dd6b4300265fbf1099", 1462329628, 0x1c008c9c },
    { 653184, "c170c51312134356032e553d7b012e88f0b3075f7623af2a074067a4e79c0ea1", 1462520366, 0x1c00a5ba },
    { 655200, "ba532f4ae93fe9213eb86cc27f8af8110516819c2ba9cec80a7cd3607d56ec1e", 1462710121, 0x1c008c32 },
    { 657216, "6f96012048409fdbafbab36a63aabb563feb4d831ad80821f39409e0dbcb617c", 1462899770, 0x1b735507 },
    { 659232, "17220bd3583cbc9f71b6e515f2d1dfc9f24fd041cfd14950b05457b67b957c35", 1463091241, 0x1c00e5bf },
    { 661248, "bbb38dbfd47264c4b4d848ca8f6e23fb252d7124bb510b0c05e964f5e195e8ae", 1463282004, 0x1c00d066 },
    { 663264, "557e4e3f327530a5bf0da0c0b3ef29edbd2fc40cb38e038ea91113442f33ad88", 1463471280, 0x1c009073 },
    { 665280, "96fd2cf8e0f1aa3b13ef8571002cdcd7fc2a85a3a6de443fe789afa5a20a0e96", 1463662301, 0x1c010f6d },
    { 667296, "c1729b8eedcc6fed2b0b4359faaa07218c5d4a10d805d590cb036fc9ae850643", 1463852053, 0x1c009e72 },
    { 669312, "316ef58ca91cec14cfb21e8e025555acb862b829f45ce875281e861217391713", 1464042325, 0x1c00c455 },
    { 671328, "fefcfc479734781c3dd0f5b29209123fde12a969788addff8373f73823e7e8cb", 1464232110, 0x1c009f74 },
    { 673344, "13affdeaa47a086bcb3f6fabe509884276a12d87f08d3712307244801754d10a", 1464422160, 0x1c009a87 },
    { 675360, "2d3929a1557def6580687a491cf5823741a13a3f2b699d77f822a0809fb05461", 1464612464, 0x1c00b6bf },
    { 677376, "682d2b3ca9dbbd936f4291976043f276cf7510812cb2fcfb18fe87c25ddce46d", 1464802429, 0x1c00b496 },
    { 679392, "f0e2e9ebe99df8ffdd24dac395bdb0754f50470a8ed224833964c42f73979810", 1464992355, 0x1c00a990 },
    { 681408, "3b56577382c02dcf83969179cdc8f19baa2d9b1d4a3a8d067f4ac921831a7503", 1465183011, 0x1c00e0ca },
    { 683424, "18241aec56e3a671f27c7e929d6f61f5cb68ceb0640977f5edfbda1fa846e42f", 1465372884, 0x1c009969 },
    { 685440, "ef0dabbc9393552f1aec09e48e4c10db1efe1e3e0a247727b6977017a11eb1d9", 1465562743, 0x1c00923b },
    { 687456, "dccc58fc7a0a59d862745dbf15cf5261f3ea2db760182596a0320a53f60a0a03", 1465753152, 0x1c0089dd },
    { 689472, "fd1034299e727f12821ae84ce970c9643ed57410206b0d92611a44cb269e5bd8", 1465943292, 0x1c0086e8 },
    { 691488, "ebc47b5077bd15e433bdb6ff3504d3330cfc8f27d8b22fcdce9d7a850ad5392a", 1466133696, 0x1c00cc63 },
    { 693504, "136542a21c91828b32d67fa20b4bffaabd0b405a38de7e6197c2d0b9d426e772", 1466323878, 0x1c00af03 },
    { 695520, "2726c8524c732eee5b98dadf98b815f5eb574d9df48eee5518f6bea6bff2bca8", 1466513440, 0x1b6613c7 },
    { 697536, "133686fa4ad64022fcd522db8383375a6f73b1f9204fe045db438dda3ef178c2", 1466704100, 0x1c0097db },
    { 699552, "cb97e0c22d9632632936e08d8ca0663712f231165a7c98aaa376064f4ee14d37", 1466893850, 0x1c00b014 },
    { 701568, "0f4458486d8eb03c871fdb79428cd97f7b4496c0456b757cd24b8816a0cfd0ba", 1467083782, 0x1b5a1531 },
    { 703584, "e13c4aeea167b76a067ed5fb666d378724ec63ff16108d3ffb33fd473f4f4ed6", 1467273795, 0x1b6b7596 },
    { 705600, "937ea6d2256dfbe8f3495fe545cce9964be566967a33055ee66bf8b8e1129d46", 1467463781, 0x1b6c29a1 },
    { 707616, "97a54da967b2aa0b7d5079ed252287cea548860d8191b09f40f66c7d864a3e3f", 1467654177, 0x1b79226f },
    { 709632, "afd2bf6dbf0f23d572309509066b177fd67f44edc847768a8aefe9723c0e4914", 1467844002, 0x1c0084d6 },
    { 711648, "ec9d678588088c367673068614c4ffa40e22baf61830e198372c8fb2e0107431", 1468033800, 0x1b7e6a4d },
    { 713664, "d87bfb15548a8ba35b138fa1dea720732abe05b211fa3bd127e083dc2e823f6d", 1468223803, 0x1b75bb12 },
    { 715680, "54fac2035ed8d3d6c21fcfc88f88e411ef6d5652886d01676608c38a572d8aec", 1468413935, 0x1c0087b8 },
    { 717696, "e641a6071aa58a36667a6b97a119d51ed54af2d7d55b1fe2ac4bc93fd0abde98", 1468603990, 0x1b7512b8 },
    { 719712, "82aac57d0e82fdb1fabb89ab33b14c2c72cdabda07a277660865ca3d9ee4d584", 1468793798, 0x1b7fa702 },
    { 721728, "02938e6cab828ca3889d511b5d7b2ffe4bc72dcf9768e03f6ddffede50eb9109", 1468984103, 0x1b73fc37 },
    { 723744, "6242331efc713a2065fe37b2c4b29672f112369f8b2a5199d25d72c373295fa1", 1469174147, 0x1c00807e },
    { 725760, "630cafc520b7ac9dc222e6a38da11c05502eccb90719d45e55bac121875be812", 1469363832, 0x1b4ac71e },
    { 727776, "87c354f3be87f596740807f5fa2e0e30b1775e340b2de1d359eb52e17596fc0b", 1469554347, 0x1c009902 },
    { 729792, "52e5ae2ac5bde7e50342835d5f6920a339fc42bf242982915f36cb2800b560da", 1469744146, 0x1b7d031d },
    { 731808, "019d705d49079f6ff15c7d3a57aaccde833e73049755c622800f47f930ef54e8", 1469933712, 0x1b714758 },
    { 733824, "185b1172280fc1451bc68265f102926a60bccf984feee754b0792f7264a0f1b7", 1470124478, 0x1c008743 },
    { 735840, "005acfccb0dedec753250b8060be68c736dfcb095c1db9a8ad31767c972b05ad", 1470314502, 0x1c0081d8 },
    { 737856, "351d0efc25f5a9728f8912b1f4f8177eb61b8d865e764e483728d2ed4d9ad6bb", 1470504816, 0x1c009175 },
    { 739872, "b1dfb2bc8212ebe257217076a4f62793a6ca8f134eab4c2ba61ac5f21a537d55", 1470694747, 0x1c00e054 },
    { 741888, "ce7406b858527d263162004ebc366d8c3f01fdc9bfaa2b2cc4933b5829327ed8", 1470884968, 0x1b7ca2d8 },
    { 743904, "7126e103e9c58e935e653d033a4fabc964f5bf9facc8593ea6e15c0430823714", 1471074981, 0x1b596cc8 },
    { 745920, "8f42e053078f6ac5fb11f825d4fa7b8da3e0e7cbb4960b5c8179fa2ad57fc81e", 1471265155, 0x1b4c25a3 },
    { 747936, "40a93f245f7bbacfd042631d51eb6cc61a8a42ed594d6d1e3d2903ae40bda06d", 1471455684, 0x1b5215e2 },
    { 749952, "09bbcecc777f0c846328a4fc404ec51befbfa9ec1660e0ce374b7fec22bf51c5", 1471646031, 0x1c00cb12 },
    { 751968, "9c8ccf2bc5e03e0fe165eb379dee3b3c7975bb979ba4caedc5f3d46e48802af5", 1471837246, 0x1c008273 },
    { 753984, "7e3545210fb28f95f599736349cc9fa2388dea451ce39104613fad86b9fffdb3", 1472026653, 0x1b6ee9c8 },
    { 756000, "fd0a6c0277249995bb9de647f54e230bc675c49bb44f63ecce36bb8c01170b98", 1472218105, 0x1c00869e },
    { 758016, "ea114943c8a681e9a3d9c0c5c90be1912aa2980dc9de8b2f2f296d86a7fef471", 1472408536, 0x1b57414f },
    { 760032, "116db40660100d7e1ebab93c5792cb7826684a3dfbe531b71a367314363454ef", 1472598780, 0x1b58aa25 },
    { 762048, "08e08f0ab7b13e358e0385bb2d07e363fa055a6d2b4ac3da8a7619838ff8854f", 1472788748, 0x1b7bda18 },
    { 764064, "f67cf15b680761e65919a6297591feca51614f2b3de852506a69003a34aa3c0d", 1472979144, 0x1b76eb60 },
    { 766080, "7df05173bbea25690d10efea3b6314d7e04c890a217ba357ede92b5c3f35ac61", 1473169791, 0x1b7c69f2 },
    { 768096, "108d835ebe153ded7c42917523b0ba4c60c0c3cf1f667b64ba7b7ec190f9785a", 1473361381, 0x1c008f3d },
    { 770112, "dc1f30ffd9707b86d6faacdbe922588e50302b6862a77f2b6dfa9b38dcf0bc9a", 1473551093, 0x1b72ae10 },
    { 772128, "092551d0ab25658ccb307a5404e6eac29556007ddf683248edef8cd9e50ea7db", 1473742645, 0x1b753087 },
    { 774144, "caa15239e08505d0a59763bb7423ae5dcb287fda6e000b628e04aabcf5c33e88", 1473932933, 0x1b62f861 },
    { 776160, "037bc19d2f796ba575a9e11a026dd59eb15c010bfae27bb55a66ffe0bcff374a", 1474122951, 0x1b5cd51b },
    { 778176, "fcb8a58d4f1be605da7693c1d436b92bfccb9b620cab4ecb413165d6088c0bd7", 1474313489, 0x1b7098bc },
    { 780192, "5b6afb75cc90af41bdd96264ecefad4fd54ceb992c348136876cd329828b00c8", 1474503942, 0x1b6b04ac },
    { 782208, "fd1c8d7d09f00fd9e1638e8851f8f19a895c9dce35b963b9119dd28fc54f8454", 1474693604, 0x1b792f0c },
    { 784224, "1ae1f302dfc69acecafc9f1997c3b8fb1df8a11ebf16a54a32eef71a55cd9b32", 1474883915, 0x1b747f36 },
    { 786240, "d80b37f544932a5f207323f2cdd32ad694a7461ee233c0f2f32d463a62b1d2a6", 1475074549, 0x1c0096b2 },
    { 788256, "344a2d0915da5affcf3c4a2baf75706f963559d7e44b4aa7b271ff827feeed4c", 1475263886, 0x1b48da51 },
    { 790272, "fdd5d976bdc68aeb813728536374b4c844c879b6de1746889e5d368b73015033", 1475454927, 0x1b6fc67c },
    { 792288, "5b5423437c2632eeea6a6a86fd90f3c9779c5496306ecef233947d1ff64056b2", 1475645107, 0x1b750c8c },
    { 794304, "c9767337fae0b32c822e8bbb379adee718ef6839e3027d792ffb48b47210f249", 1475836571, 0x1c036ea5 },
    { 796320, "35a10654cc540abd1eb59c46e7b5c9728485ec70d51e0961635e948494acb90c", 1476025650, 0x1c008712 },
    { 798336, "5ad82b7c13ffd08364eddc4bcda671cb97ccbf04d0223b01ab09dc0e5ba3df2f", 1476215589, 0x1b757fa7 },
    { 800352, "d396943cf1dc257bd577172f6aac4f3319bf22d494ff8c96a509e41caafaadf8", 1476404931, 0x1b653d23 },
    { 802368, "b922af0924c24d3b7c66bbc4815d20fbab1f7e8e7f8be6575f5319816474dc64", 1476595074, 0x1b3f0afc },
    { 804384, "fd858271ceb71254211bc2bcafea1a603cb844fc14055fb4e0a158e98fefb93f", 1476785029, 0x1b58b2bc },
    { 806400, "4987de18a5ee0896c252a09521fd568312046b142c5b36ed73b6000685ca3479", 1476975211, 0x1b622a9c },
    { 808416, "c992b15550bd80a77623b3dfaa8dec1a83e1d728abff8773d6489e98363434ab", 1477165228, 0x1b49097c },
    { 810432, "a3ff136b865b1b0cf6e1e333555115b45e06ccfe8e8f7a8486038a5ed0075ebb", 1477359392, 0x1b552334 },
    { 812448, "8dba13f006540e455b68dd958d73d09bd23835fa55a88d63a5ffd906d639b684", 1477549264, 0x1b4f43c8 },
    { 814464, "7a114a05b4cc8b39ce3b7fde729c02f656b0c23ac7bfb4f4df4434d564a947b1", 1477740253, 0x1b737d8b },
    { 816480, "dd7f0173b3c740b63f41104c3c051e301356c10ba826ba89f2bc067a6c2d716a", 1477931439, 0x1c009b6b },
    { 818496, "0049bae59bfe0c7a2aa3bab470165e92cdbfdb0f8e799f3dc7b5e6448172307b", 1478121071, 0x1c009041 },
    { 820512, "cfc32a43321fb4dd0bf27e33e0fb1f29709bee16c87f9f81093f442a6fd7ebb7", 1478311245, 0x1c00b57b },
    { 822528, "6d089ee6c6a3dac1607d5e1400835eaff0f16e5afbd35f6b44ae3aa238a3a130", 1478501176, 0x1b7667de },
    { 824544, "ce4795f3f9b8f00a848f40decd17829b76deeac7bb69ce8d7499cd9723fa9001", 1478693740, 0x1b79b358 },
    { 826560, "18b8d334b73cbd40dd04a3c6831e2c70a45cef889401216c1eb0fc927b690df1", 1478883912, 0x1b6dc290 },
    { 828576, "45c91c7bb6aedd85e604b818aa351f0415ee12db18fddee54cfb59b944c5d63f", 1479073460, 0x1b696113 },
    { 830592, "190557e622580aa8939988cb02137dc83a8477be256dedec543b058349444b1f", 1479263316, 0x1b76b787 },
    { 832608, "d7c6fc4cf635e5ab729e662afb025215869bc344a960458ed5134008b6fece09", 1479454115, 0x1b651deb },
    { 834624, "28908c802863682b360ae95211998614deb8b7122bd4b09ade0c42e4f8cc3af4", 1479643709, 0x1b5d4c70 },
    { 836640, "c94b932a7b3719d93dac0cdcad1a44a1965ef18066a758d465b3e721f0b4f399", 1479833761, 0x1b60da27 },
    { 838656, "a41393944321d7d7a241d44611a2a36e6bddb2c27ade59da9f9b1adf2d4c234d", 1480024329, 0x1b7da20a },
    { 840672, "0f91638f6437451f50eadc449ef5f8acc16d8e78a4ccde25a90d39544530d10c", 1480213826, 0x1b64d1c1 },
    { 842688, "9b776340d0f084ec5598437a280cf19634c1d25b44576063e7db7c116032b204", 1480403442, 0x1b6974eb },
    { 844704, "3c0e8adc9599f49553ba62c38cb74f0a809a494e52b784e66350b39a6002dfb3", 1480593364, 0x1b5e134e },
    { 846720, "921feaee9336ad75a2838c06b865c3bf3e9d26a966aa6e8d72562cdb4c127259", 1480783534, 0x1b5cbde7 },
    { 848736, "f332789aa65b4f1adf93b5639b66f3aa50b5d4d483782e81be4f706cd26bdf1a", 1480974038, 0x1b5599fb },
    { 850752, "8ab092a5f1fd8d2665e5e9ecb8197ff945c04375564630bc77e112c8d4257ab8", 1481164513, 0x1b62dc03 },
    { 852768, "1e429e47f832babc10b293bca945c048087ea81cf497913672e4cc3bd49f6af7", 1481354113, 0x1b6bf9d9 },
    { 854784, "b3e5541b29cd6ac0a2fa7e4f531216c71ce81841d382dabf10e2cca2401a1a5b", 1481544467, 0x1b584d3c },
    { 856800, "70da1604ddefc468233e859246263cf14985a3403ab0baa448d705aa7016aac7", 1481733823, 0x1b664917 },
    { 858816, "a03b2d2ececd2de7884b7836890976668ccefc2800952cb36a8d64443cc18984", 1481923741, 0x1b5ae87d },
    { 860832, "f5d1941bd2463152b0b3d9f4d1b22406b0ca2ae6e036b2c8605d88d4d358b722", 1482113476, 0x1b5e7732 },
    { 862848, "a3476f9c0ac3d909cf8365da75957cfb2fbc069fabc72d0cf8bb778433b8fb0a", 1482304063, 0x1c00809a },
    { 864864, "76d8877ab5824851373811067e305d4670cfa32e0af23762f484a12244141c50", 1482493630, 0x1b55b04a },
    { 866880, "2906ab0dce8fc63213588a756bad7d0e9b1453b79a9cd6a43f0f9a61a10be202", 1482683595, 0x1b654b38 },
    { 868896, "04ae4ea275fcde5e40df8fe54943ab0383393c673580565bba169bb35f31311f", 1482873595, 0x1b78e6f2 },
    { 870912, "2d6790ad69c32030f240c8c2a112a0818e699608e5439a0b8f94299a6fbd9e87", 1483064897, 0x1b786fbc },
    { 872928, "b9f4b7d042aceec25c4343f077f2125ab1985b3d1f55cb52e32f7be047b4b22d", 1483254703, 0x1b7d0272 },
    { 874944, "086dda5f084126a31e22f466cf2239c5ed51535d7b89e811b9224823f766e439", 1483444252, 0x1c00968d },
    { 876960, "df53548e1b5270666b9e2ecba1018951a01c119e36ec1bd566fa03a153a64e00", 1483634600, 0x1c008336 },
    { 878976, "b23dc6286c2fb6b9a16e760a4964ab05c9911d62cd8248fa57bb266c721c5932", 1483824523, 0x1b60aa7d },
    { 880992, "93b4efcee1b574c45c467d0ba9c484968b6336d61ef7046c16e71e9da765f791", 1484014372, 0x1c008636 },
    { 883008, "fa512d928ad4700886999e8e49fd3e65fe999606a46255d72f62fbc046e7a18a", 1484204905, 0x1c0093f7 },
    { 885024, "e61caef87495e11b802ca5580c71b70f91f2451afbc92eaca844f3969c924352", 1484394581, 0x1b7c5e91 },
    { 887040, "517755cb4c0f5893bab3b65a865e5929464678e6223db4761f0db31dbd7b678f", 1484584189, 0x1b70922d },
    { 889056, "4b0e1733c364dcc387c30c38e6049b4d2a358935e5e171a8cf31af396bcb1de8", 1484774858, 0x1b7383d2 },
    { 891072, "168a43be2f487d22629c181fce8c146d8160249ffd3ab66d79e8cbfdcba45512", 1484967408, 0x1b7633be },
    { 893088, "35975f8d14090636f9ea448271e7b38e8c02c543aefdb4e900e31ec41e3bb097", 1485165131, 0x1b633a10 },
    { 895104, "bd0fe5d5d9bbea47b80ca86714cf427faefc2fbec6e0aaef9eb9e9714f5e75ee", 1485366493, 0x1c00804b },
    { 897120, "d5ab2fc524d39bf372f92d795a9fda7028301d2db99e127924cdc7eb4b794773", 1485558884, 0x1b693575 },
    { 899136, "b1ec7111123b649ac40a41675fb5cdee3ddc83bff749096c9ae85454505202f5", 1485755772, 0x1c036256 },
    { 901152, "3a657a51bf3e78cb137a894a2c61542a7e8391cd22d4909c6f9311467e8c2cc7", 1485946214, 0x1b791398 },
    { 903168, "b1951e085b3782453e294622b14e950fff007665c13b49b93f2dfeed9311dcf7", 1486139308, 0x1c00cb40 },
    { 905184, "1647e056dd36481fb55349a7244caa1a6d7248866148158c2b35f420d62c7e3a", 1486332292, 0x1c00e40f },
    { 907200, "cae1cc406fd228fe57e44b157c5f204772002b0c67f99cd5fcc18452fe748bac", 1486526968, 0x1c00864f },
    { 909216, "5cfb74e425449774c2bbd4fda3667a7c4d09e2c4defdaa4a5800569ce56da4c5", 1486720986, 0x1b518369 },
    { 911232, "b06312de81228b2bb26907c7b1b30dffdb312ff40d22df250487922f2fa4547b", 1486915681, 0x1c00b393 },
    { 913248, "dd19095c579e1ba43748332de65012408bf30a8efd87b485a76601409355972e", 1487106084, 0x1c008bb8 },
    { 915264, "e05b615a0fcefb8f096f68e0e48ca2148d188274b165125b601082c3b9da8e5b", 1487297950, 0x1b7991c2 },
    { 917280, "9389c012ad0d2ec65f241ff89fa3b6680589e626d95b4fe6dc2db45c100d0c95", 1487490260, 0x1b5253ff },
    { 919296, "0276d8c3f8aa60dc466927ecb534c429fa1bb871e94417e18bfea2f4f3db0e73", 1487688499, 0x1b6c66f5 },
    { 921312, "c513edf181934f179523bb0d2ab47ee97db5aefe312f102ef972577ccde5af30", 1487885171, 0x1b76a871 },
    { 923328, "6e1a32754091562cca49c050b7fd6bff2ff1c446ccbe8221529b921e10968908", 1488079740, 0x1b4ab1ab },
    { 925344, "6d41a14e9491b741c2bc9ce73cf8622d55a0bb01af4368db849db86e9cfe0fc2", 1488270601, 0x1b5708d1 },
    { 927360, "1559a1e61da8060e21aec86bc071630858eecf96f4910218a697f07fb45d66d4", 1488463085, 0x1b4a6531 },
    { 929376, "bbbfce1c5a1ff6c7e4f392d899d62c2b2d87542b9c0b9af548b5fb38ff69188d", 1488654158, 0x1b3db8b6 },
    { 931392, "c645688b6a17c32c3449d07505c12897d1b2349aa56b3a704eddaf67ecdaaf7a", 1488849039, 0x1b778da0 },
    { 933408, "e18ae2aaf19632d5341821d1b5acfba47a2641c0f1f32e34db903fdfe06214ce", 1489048799, 0x1c00f9a6 },
    { 935424, "aca9b1b33fee9c85036ca777398872242d86b144e4f6005b4017cf51bbd4db84", 1489240746, 0x1b4aacee },
    { 937440, "7b29137343ada47206f33e84c9acb2b33d818ef9800658b57c7766a06ce5a696", 1489437677, 0x1c00f3bd },
    { 939456, "d653152b24f36a1b93fe27bdd104b6ae852439d8793f6f2a2ee13466695e7a5d", 1489630117, 0x1b7b787c },
    { 941472, "d3d80749b316ef3a5df1f75b7d3865326826852b1c5d3dfb3e0df92b9a9f6130", 1489826155, 0x1c008a68 },
    { 943488, "e560369fa25604a2c768984c44ba6d8dc210be33257c4a13267db661c65f654c", 1490025770, 0x1c016c41 },
    { 945504, "f7b73ad64e09b6b29e018495ef88ea3b7ccaa36dce69f7affc89c6e882ea454f", 1490219849, 0x1c00d940 },
    { 947520, "41ae9c7b3ced403a21bdfcfe6fc07c29eba9a2abc489c5cc347c006722f87c39", 1490412058, 0x1c008d2c },
    { 949536, "64f8a028c57e415626b374c71b59bf8b94dc234831c9896016c4e2046eb62302", 1490605314, 0x1b5f8561 },
    { 951552, "7f98d81a39a25d36be2cd392a4d62d468693373c4e1247d6fe94e0643fb51efe", 1490797425, 0x1b47a3d5 },
    { 953568, "284b8bd701b4ccbe41a53acd9b1cac5cab108bc128de006ffa19134e82fff535", 1490991513, 0x1b71ac86 },
    { 955584, "1388ad43ae835c97448376b44c5c42918bf1d3183a6e7bb79d9b8c08ba08f36a", 1491186356, 0x1c0082ed },
    { 957600, "b4ef58861c2b3a25935fa834792ba9d3ae37a9a9c824c4ed1b3c017a0f405c2d", 1491378320, 0x1b797f55 },
    { 959616, "0c196c5ed34972a8406172e64db50ff5670a7a2a90d9e6c11f0f23f3148ccfb6", 1491568603, 0x1b2bd492 },
    { 961632, "c7d3a53fe77468e9fe184e0f393fa1a90e5b3c9096b4a7177e177338a752d616", 1491759967, 0x1b380149 },
    { 963648, "56271fcf5777175494675f52d1205b1d69f77ca0d89244d9e671d6c43ed156d3", 1491950840, 0x1b2dc2a0 },
    { 965664, "36d82e2b617a07b13c95936259553e79a26d6ce675b4da26334339edd83ca8a8", 1492140853, 0x1b28a77e },
    { 967680, "6d8606a9ad195a8ef3820279be0748dd726ffc5397db22b0857ef915c4a9e511", 1492331353, 0x1b2a2d5a },
    { 969696, "9b6c225c44eaf3caec18dd13d32196064b80cf23550851f23dfeaf077e101966", 1492521232, 0x1b25ce11 },
    { 971712, "df9f63638f2bfcaef58375c2fedd2557fa832d6efc972a91be5e0676ccadafec", 1492711146, 0x1b262eac },
    { 973728, "090e6c0feec158b3515e46bc48497e7c74de8a5c62b7cb3f82564768b7c0c5bf", 1492901289, 0x1b262d5e },
    { 975744, "3c5680acbb2ae0abd949b36ff2e11defcc190f68807717db824f64cf5aee3bcc", 1493091664, 0x1b608f00 },
    { 977760, "00cdaf76200737d9a7f94cc058fb132868c18c50c0342c77fc5a5bf0ee78be0c", 1493281783, 0x1b235bf6 },
    { 979776, "350e4fa25ce5727d2db71b5922615e3c9e74d9046e29464f342c676f141b1c50", 1493472289, 0x1b1efd65 },
    { 981792, "31d357b9a84a9fac4cd08dbefe9f12297c1dfcf6f718b805154ccf39936a03c8", 1493662972, 0x1b3196e6 },
    { 983808, "3a6299ee219610761da48b08d5a9d530eea76e67870e4d87c5d7d949f46e2a7d", 1493853524, 0x1b20ea2d },
    { 985824, "5c8df00883889084e4090d36e4be39ad4507058d71aec8904551285d3d3e6270", 1494043654, 0x1b405051 },
    { 987840, "2bbdaec34b9a10daaaff7e0f94b600b9ea9780841c0a9551bb63babea1dda58c", 1494234866, 0x1b52712a },
    { 989856, "e6984d9a2b3501c7c476af5b460cc2818f00b3179154aa4a51731fbcef7225d3", 1494424032, 0x1b3426cf },
    { 991872, "b0ee26202643c37ed3000618aeeeb4c708c35cc45d434785574b44d86ffbf849", 1494614820, 0x1b2d75f7 },
    { 993888, "c5e97b484fcc1374ad1ff8e46848330f2f85611e25b527e39f238102b5ed4ffa", 1494804859, 0x1b2666a9 },
    { 995904, "ae8cd53369ec98d6f4ec4ea743449d74c957364869a57cd9030a1e9289ecc4a0", 1494994756, 0x1b2d59cb },
    { 997920, "88ac81001fdd06a02fc7bf197b9353340640faf38d0f1dd3c1c12fcd42fdfd37", 1495183778, 0x1b0e8e1a },
    { 999936, "0da6e449536f67625566993288c6d582d86f690107ba0519f5f11a923363dc33", 1495374551, 0x1b16ce18 },
    { 1001952, "84c43fd5e89755423cbf08203878bd5e8ce87e0fc80f02d19610e5fff76d7110", 1495565899, 0x1b27d841 },
    { 1003968, "9fee65de50ccc2b34b5a66104be2e0c731a3b0718829de550a8f33abb8b9768a", 1495756471, 0x1b1b9bb6 },
    { 1005984, "ae17541fa1b410f396cfeaf111bb57b704dea66c6b0eb9a41b6d711731c1f6df", 1495947078, 0x1b1ad4f7 },
    { 1008000, "0941421e644b7a1a872b2809a1ae43e8da3dbf4d925fae34caa9cacd2859c614", 1496138162, 0x1b18edc8 },
    { 1010016, "414b916bd65986bc773b36c24eee6268f7199db98a8e59084cc2e1b3f5a7a850", 1496328151, 0x1b19904b },
    { 1012032, "038921d5134eca2f189b3d8246e29f619c6add352a3d860138e3d0f09f4d4ac4", 1496518749, 0x1b1b9335 },
    { 1014048, "eb824050d3019b6f365b4743001ddb5de6ab27bc37fc60873ed89df4e227e65a", 1496709238, 0x1b2a3ad3 },
    { 1016064, "7c7687ef434f02159fed9f3978a7e9152b154da110915243feb42f13c5c013b8", 1496899722, 0x1b291600 },
    { 1018080, "ee4155a17f1c2e12fe09820c2ea39975c600d45ec0706f5d31de89844b98d1d7", 1497089300, 0x1b1d6241 },
    { 1020096, "ce0d73fd4927e685642cb786395cee3dc21c7763c177495ae615b9c7fc7c2f90", 1497279842, 0x1b1edaf6 },
    { 1022112, "baaf940422db5b910b3797b84e076ced2b6588eb8cc74325ee94dfd42ab0c3d1", 1497469853, 0x1b1b2d38 },
    { 1024128, "e34ae9b5ac637c0dbba2b21d1fb0fc176e3f7431a90d80be9b946a5d9616ce9a", 1497660126, 0x1b24aebb },
    { 1026144, "ec676f083ccc1d1d95d73bf1aa666efe7778c8c37f5e9cbe1a22cfd0f9309416", 1497850404, 0x1b0f588b },
    { 1028160, "bbff6a403af011a910db0ee795dc9501879e9ce4b305f507fb040ddd8bc3d19d", 1498040477, 0x1b0b0a62 },
    { 1030176, "27129550d3529ce32f75fab315de85b9f39376262f4f478ff27054c05849722d", 1498230581, 0x1b0f2499 },
    { 1032192, "d6f133232ed9fe038ed9a894efcad147d7b87180b6df828d60f50c72d585ba42", 1498421285, 0x1b0c01db },
    { 1034208, "a4bafb3e1caf80e675e537ea985a58f4c08f2c0c4b5564804b4fa6b837febd13", 1498611521, 0x1b0b3c2d },
    { 1036224, "fbca8a9afd1ddb20e7ea7ea4806afba9c1ef73eb4ec24b62c2653c53236e4e74", 1498801088, 0x1b0539ad },
    { 1038240, "9bb5bcfbf6e6f738540acb9b04bb5861e7e1eef080d998d361910f41d7c9c58d", 1498992162, 0x1b083813 },
    { 1040256, "9b088ca92945eed5f4d1b4b38942feb1c4851967ab02a5761cab3033686a8350", 1499183328, 0x1b0c1a2b },
    { 1042272, "48f9639daac8d56912d7cfb41661444f8530c8dc0b5e241eb7e2921884c23c17", 1499372693, 0x1b079dee },
    { 1044288, "ec79fe89cf518a25418d3660910a991a428ce275dd0f61d55fa20f3923abb02a", 1499562974, 0x1b045f8a },
    { 1046304, "2a9fb49cbf7b85f19a70967d335ae0cd449f84177c25166bbd8ec68bd198861c", 1499753287, 0x1b07f47d },
    { 1048320, "b29480fcdc26752d203e3464cda458be13aa564cadc04c61bcd8fe2c7331856a", 1499944289, 0x1b071821 },
    { 1050336, "b78773c257dba5623cb60c0a916e401e687ce39a22878c6a88754d68ab1ffc99", 1500134932, 0x1b0718ff },
    { 1052352, "53065ff42132bb79de42b8bd47475984811d1cfc83062d6f8c2cb77957f498fd", 1500326522, 0x1b0c07cf },
    { 1054368, "50d33e9196199c61ffffc7351a7a13701a0737741069aac80ed93dfdd0d80cac", 1500516863, 0x1b10e7c8 },
    { 1056384, "45e47b8513e59ee50ca165ffaa7447ef8c129e9e61934ef34b5fd23a7e5eb212", 1500706726, 0x1b0cc3bc },
    { 1058400, "ce3fdd0091d376695fc82df5bc5ab807168d6f35d2a7cd2a29ea4693cac76cff", 1500896922, 0x1b114249 },
    { 1060416, "e4d34b4a9b204c7d255c7d0c2e5b57c8ae25943b4ab7b44f88d3c913e0b9bb98", 1501087293, 0x1b094543 },
    { 1062432, "104fb3f0501bca78b82d3794e5fd55d6a401ce265560c36c4a413e40a1349063", 1501278158, 0x1b0ee47c },
    { 1064448, "1aff85054601fbb07b4efc2b1b81194df765819b2ef1f44fccd510b1b32c440a", 1501468282, 0x1b0c48b3 },
    { 1066464, "638ed6fb804052d8687f334d7daaf3c9f0617bcce60dcd66129f4a4c8c056a22", 1501658927, 0x1b0efc0e },
    { 1068480, "3b3d28595629b11106ae4eb994c92f273eab370f1cf947654b5017b9d4b2cc3c", 1501849339, 0x1b0fb54f },
    { 1070496, "1c1a2c8cf91a310bc5c60076982ebf9c339aaa36d840532310edeae4515ea17b", 1502039766, 0x1b0f5f9a },
    { 1072512, "e2d60dc84a2d8b245d6915fb565a7cc76d9af2353b3109fd4cf397c7569aef94", 1502230224, 0x1b1282d4 },
    { 1074528, "d716acc3d52f43a9dab1190973bd0729e5a9466c2ef21e3d2b140bb3f3696f06", 1502421929, 0x1b1a84f9 },
    { 1076544, "080842bf1f46e00e28669f03ae4e479a68a2633157725f38ffd59ac85fcab769", 1502611064, 0x1b0e9202 },
    { 1078560, "dcce445a3be38fe7de117e8736434945f22a437b96ac2c0ac01eefb868c7eed2", 1502801536, 0x1b0d8a1d },
    { 1080576, "9de708da7e1a5623e18f3f0a88b98ce55331e7ad99f5c0a0cb68b4d1ed373675", 1502991879, 0x1b0cce5e },
    { 1082592, "d595d952f26e402219ae286034b718e7fb2ff3a2e9868d88481f644637eedf46", 1503182430, 0x1b1552ec },
    { 1084608, "bb874011b8017d756f52949ec9bb10022178c667dbf2dfdb6feb195a94d632ac", 1503372961, 0x1b10064a },
    { 1086624, "6e91acc9d51b91942d3ac66e995c176ea5fbbe1187d6183cbaf0f339c6ec7c0a", 1503563319, 0x1b123f72 },
    { 1088640, "e2a7b185a55b72f9a46e93c896d6c602d83ac910639c8b9d19baa40fa2b0cdce", 1503753490, 0x1b0b0b06 },
    { 1090656, "b88cccb4d7ba6dce8c1ae3819f391e34a77247da56edb9d24f314a226ff28e60", 1503943423, 0x1b0fb729 },
    { 1092672, "fac867fa21127aae53a5d82b8eb27975e8eb8e060e1e92c4ed5cc09f6790882d", 1504134165, 0x1b135896 },
    { 1094688, "d1685f0c3fd958c583fe3cee8d933af9f8bf9f18e692ebfc468300c6046747e6", 1504324105, 0x1b0ebcb2 },
    { 1096704, "c3c686f670871c3a2f8e1a696e246b07822444ed03574e66dd57a0b961f781e7", 1504513866, 0x1b0bafd8 },
    { 1098720, "bdcd64940ef90ec5e844e4c5296c51fbfd1f071cd7ece882d8b5833ffdee51f2", 1504703926, 0x1b0c8681 },
    { 1100736, "a08fd00e3838efb0ac90fc07797aefa0d7920195f217e16b80fcbb15749958aa", 1504894853, 0x1b0d5ecb },
    { 1102752, "804fcc15d8ec72aa0f21f45e735a86142c0b23df26a13d952eea1cea61d2f58b", 1505085295, 0x1b0b5efa },
    { 1104768, "e52673c1fa44600c07784e34acdb4034cbd70a5fdb67f30db773556ab61741c6", 1505277828, 0x1b106913 },
    { 1106784, "503fea7d299cc7e3f3b81a8d099c5bc29acd277e895ac62b043e8b359240e36e", 1505468755, 0x1b0db186 },
    { 1108800, "5be09a3965912fbe9c56d41140df592e92bc6b72b57fd96dda163623ac83a9e7", 1505659451, 0x1b07dbad },
    { 1110816, "3fda61f70a79dd1828239d60e86f5de657362694c307c3573b90e7649d2f2f11", 1505852492, 0x1b0ee94e },
    { 1112832, "3cef696f69b3496a9104831867cb6cf7f9bf7a3584a3100af19dcee88f28f085", 1506043602, 0x1b0c80c8 },
    { 1114848, "d8d79b76a239892921748d581c61f8e60d3db09eac87cf4b018b07e278241d3c", 1506237314, 0x1b129d19 },
    { 1116864, "815774c317a37102da0e3cfbb5a54ff9345d87f8336626bd66b598196c053693", 1506427772, 0x1b0d27d3 },
    { 1118880, "9293e75d2a17178c46d1bfbd89065355b4b1628bd2a68bd9a8004fe264016b56", 1506619233, 0x1b0aad39 },
    { 1120896, "5a9b808e6b7760e559a56598aab756792e6a5984b38364e80270231ce59e2eef", 1506810463, 0x1b0d99a7 },
    { 1122912, "1169ecf86b889bf7dd65287d369e5e0d7c0155ea433b16f8d2f5c7cc778704aa", 1507001055, 0x1b0ae058 },
    { 1124928, "9cd36c53e719e77e60fb69ef55d045c36de93f96a036476495c1766291d5076d", 1507191362, 0x1b0a1c28 },
    { 1126944, "8c6be0ddbbcdbc050ff959b41f1c38e1d7b192a4d4e74afbc17c207b570d8c65", 1507381572, 0x1b0921e9 },
    { 1128960, "9821a6ffb32313c7a452ec0460954a317f5a89740a5e0537d95e3bdb8250169e", 1507573237, 0x1b11a604 },
    { 1130976, "a4d484429b48ff9dc57dca8c0d56340623b9c2d7c7d8f61554dca21b23a5faf2", 1507762383, 0x1b02e31c },
    { 1132992, "df5d1c46205bd0dbbad8d293c95aa91a37d28bd1b8388ca0afa38b783f9191e4", 1507951712, 0x1b014c2e },
    { 1135008, "20003111e6a3ffe6633b15d9ad68c818f4561f1e256ebcd51c1634e679d8aa4f", 1508142127, 0x1b016b05 },
    { 1137024, "51bd87226856e9ea3663e8a0d9a9fd111843cfcf56d5ff99be914ed98e5c6dfc", 1508333488, 0x1b039c26 },
    { 1139040, "0699b4c04d360470fb7515bb2b36d886365519444bf75eaa9322cd56b11996ac", 1508524507, 0x1b02c873 },
    { 1141056, "87c8f78b7a7263ae5b34c5f17c25a74e34678aaae0d5a288920e6c85b2bb9956", 1508715278, 0x1b01f5b0 },
    { 1143072, "f3cbcb0b84d15a61e0afca2a87fc53a37135be4a5f4bd9dec765c78443fb2511", 1508906386, 0x1b01b1a1 },
    { 1145088, "c2a40577327bc4de6b93053a547c179848712ca033a708d0abfcc16e5897a7cd", 1509097970, 0x1b01ee45 },
    { 1147104, "607f12b57c77b42022c3ee5de28f035b31fed19fbe4152491c31a83e2dbd4fba", 1509289499, 0x1b026ffd },
    { 1149120, "ab338f9dbab94687479ef01768e5975c05e68664d86f45a25da679429d8eb04f", 1509481030, 0x1b02be15 },
    { 1151136, "f2bbfbf43286b868743c7ed9cb51e9e583609948ac6944ccc97ad86e345d1165", 1509672553, 0x1b03c2bb },
    { 1153152, "22ff69fc7f618af80671465ca6b7cf456cfb41b284c977e3093a98fef05b5f26", 1509861907, 0x1b029e09 },
    { 1155168, "d95b6ad8dc8024146bd62344fe785c8d17f155c88f655d5fe68c848c2d8de705", 1510054530, 0x1b02874a },
    { 1157184, "d28ec572f75f053af4bf55b260475c4aae4088aedf3e2ec43bc8f4b0e92f3ecc", 1510245487, 0x1b024f99 },
    { 1159200, "e21a7cbecae08a1d60255120dc06166107c967150ec7d001e339bd944ffb5332", 1510436121, 0x1b022ca2 },
    { 1161216, "7a59aef0f4ed602cf5e41831f2097dd53793560f4f072e92c0496ed260a1e264", 1510628183, 0x1b02a73f },
    { 1163232, "d2d34945204eb987e27340bccce3d32e74098ea799e997a289212dc9aa881294", 1510819466, 0x1b035154 },
    { 1165248, "8c80574b54c2a20c6485b5e7eb94fe6d0a145cba7eaeb3ebbebd4b0b9a093f25", 1511010203, 0x1b02d048 },
    { 1167264, "90aa70fc12a342a33ad7a31fff0c2b172e2c566e06556aef03e0e8507e50fb65", 1511200502, 0x1b0356cf },
    { 1169280, "9b84ef2142d308b3b1c6fba34af0cdb013ac2121d2ece90938ffd447a152ed8d", 1511391511, 0x1b023d79 },
    { 1171296, "d6876e39f1b5defaa8ccdb4a7f7f4e94723a5cbfd6d5a9322776147f9ead97cd", 1511581925, 0x1b01e8d3 },
    { 1173312, "8d77413e1c9ea73298991582b65271fe17b07e8d92c592b0b86d638574c5684d", 1511773482, 0x1b0244e9 },
    { 1175328, "d83f51062218c11bc1ce823af0feb770745d80c52f8c9ed5c70396396896011e", 1511963454, 0x1b0217a9 },
    { 1177344, "1be87022fefa34c0b8d031d390e225c2df45da87be526d43100f6e492d3edc97", 1512155456, 0x1b015227 },
    { 1179360, "5c254835a8d5534ec06cb1b9630fc5b210a74c04328554312050c44f7b5aa26c", 1512346872, 0x1b01b253 },
    { 1181376, "c30eadc887da57d0871eb3a3f05d34d026dc4d71f853a20b3a7221599c8c7102", 1512537625, 0x1a7c5c51 },
    { 1183392, "7d2fd54f23afc7d7cecf1b2139ad88b1ade62e41cc193dc3245bd09fd072aaee", 1512729358, 0x1b01365e },
    { 1185408, "da376d35ae570a6b1221617f4545deda86f9029c06a6e0163b0c05f928173c64", 1512919703, 0x1b00ceb0 },
    { 1187424, "0f84d8b874f89d9603394e822a949c11a538f7d51dac7a5716a82aa6a5887dbf", 1513110757, 0x1b00ce6e },
    { 1189440, "a7820c63aa26edaea1ca93538b2d8dc2ce82421665c5a8b90ace6e90b0455bdc", 1513302251, 0x1b01b164 },
    { 1191456, "00801e08923fa327f16926e0f19a17ed069efa7b98ae324777c4430711245568", 1513492739, 0x1b0120bd },
    { 1193472, "91d64d969ebcf78c740c196e27775829ef211bfeef2eee47d9a54a1e60f89cf8", 1513683925, 0x1b01191e }
};

static const char *dns_seeds[] = {
    "monacoin.org.", "dnsseed.monacoin.org."
};

#endif

typedef struct {
    BRPeerManager *manager;
    const char *hostname;
    uint64_t services;
} BRFindPeersInfo;

typedef struct {
    BRPeer *peer;
    BRPeerManager *manager;
    UInt256 hash;
} BRPeerCallbackInfo;

typedef struct {
    BRTransaction *tx;
    void *info;
    void (*callback)(void *info, int error);
} BRPublishedTx;

typedef struct {
    UInt256 txHash;
    BRPeer *peers;
} BRTxPeerList;

// true if peer is contained in the list of peers associated with txHash
static int _BRTxPeerListHasPeer(const BRTxPeerList *list, UInt256 txHash, const BRPeer *peer)
{
    for (size_t i = array_count(list); i > 0; i--) {
        if (! UInt256Eq(list[i - 1].txHash, txHash)) continue;

        for (size_t j = array_count(list[i - 1].peers); j > 0; j--) {
            if (BRPeerEq(&list[i - 1].peers[j - 1], peer)) return 1;
        }
        
        break;
    }
    
    return 0;
}

// number of peers associated with txHash
static size_t _BRTxPeerListCount(const BRTxPeerList *list, UInt256 txHash)
{
    for (size_t i = array_count(list); i > 0; i--) {
        if (UInt256Eq(list[i - 1].txHash, txHash)) return array_count(list[i - 1].peers);
    }
    
    return 0;
}

// adds peer to the list of peers associated with txHash and returns the new total number of peers
static size_t _BRTxPeerListAddPeer(BRTxPeerList **list, UInt256 txHash, const BRPeer *peer)
{
    for (size_t i = array_count(*list); i > 0; i--) {
        if (! UInt256Eq((*list)[i - 1].txHash, txHash)) continue;
        
        for (size_t j = array_count((*list)[i - 1].peers); j > 0; j--) {
            if (BRPeerEq(&(*list)[i - 1].peers[j - 1], peer)) return array_count((*list)[i - 1].peers);
        }
        
        array_add((*list)[i - 1].peers, *peer);
        return array_count((*list)[i - 1].peers);
    }

    array_add(*list, ((BRTxPeerList) { txHash, NULL }));
    array_new((*list)[array_count(*list) - 1].peers, PEER_MAX_CONNECTIONS);
    array_add((*list)[array_count(*list) - 1].peers, *peer);
    return 1;
}

// removes peer from the list of peers associated with txHash, returns true if peer was found
static int _BRTxPeerListRemovePeer(BRTxPeerList *list, UInt256 txHash, const BRPeer *peer)
{
    for (size_t i = array_count(list); i > 0; i--) {
        if (! UInt256Eq(list[i - 1].txHash, txHash)) continue;
        
        for (size_t j = array_count(list[i - 1].peers); j > 0; j--) {
            if (! BRPeerEq(&list[i - 1].peers[j - 1], peer)) continue;
            array_rm(list[i - 1].peers, j - 1);
            return 1;
        }
        
        break;
    }
    
    return 0;
}

// comparator for sorting peers by timestamp, most recent first
inline static int _peerTimestampCompare(const void *peer, const void *otherPeer)
{
    if (((const BRPeer *)peer)->timestamp < ((const BRPeer *)otherPeer)->timestamp) return 1;
    if (((const BRPeer *)peer)->timestamp > ((const BRPeer *)otherPeer)->timestamp) return -1;
    return 0;
}

// returns a hash value for a block's prevBlock value suitable for use in a hashtable
inline static size_t _BRPrevBlockHash(const void *block)
{
    return (size_t)((const BRMerkleBlock *)block)->prevBlock.u32[0];
}

// true if block and otherBlock have equal prevBlock values
inline static int _BRPrevBlockEq(const void *block, const void *otherBlock)
{
    return UInt256Eq(((const BRMerkleBlock *)block)->prevBlock, ((const BRMerkleBlock *)otherBlock)->prevBlock);
}

// returns a hash value for a block's height value suitable for use in a hashtable
inline static size_t _BRBlockHeightHash(const void *block)
{
    // (FNV_OFFSET xor height)*FNV_PRIME
    return (size_t)((0x811C9dc5 ^ ((const BRMerkleBlock *)block)->height)*0x01000193);
}

// true if block and otherBlock have equal height values
inline static int _BRBlockHeightEq(const void *block, const void *otherBlock)
{
    return (((const BRMerkleBlock *)block)->height == ((const BRMerkleBlock *)otherBlock)->height);
}

struct BRPeerManagerStruct {
    BRWallet *wallet;
    int isConnected, connectFailureCount, misbehavinCount, dnsThreadCount, maxConnectCount;
    BRPeer *peers, *downloadPeer, fixedPeer, **connectedPeers;
    char downloadPeerName[INET6_ADDRSTRLEN + 6];
    uint32_t earliestKeyTime, syncStartHeight, filterUpdateHeight, estimatedHeight;
    BRBloomFilter *bloomFilter;
    double fpRate, averageTxPerBlock;
    BRSet *blocks, *orphans, *checkpoints;
    BRMerkleBlock *lastBlock, *lastOrphan;
    BRTxPeerList *txRelays, *txRequests;
    BRPublishedTx *publishedTx;
    UInt256 *publishedTxHashes;
    void *info;
    void (*syncStarted)(void *info);
    void (*syncStopped)(void *info, int error);
    void (*txStatusUpdate)(void *info);
    void (*saveBlocks)(void *info, int replace, BRMerkleBlock *blocks[], size_t blocksCount);
    void (*savePeers)(void *info, int replace, const BRPeer peers[], size_t peersCount);
    int (*networkIsReachable)(void *info);
    void (*threadCleanup)(void *info);
    pthread_mutex_t lock;
};

static void _BRPeerManagerPeerMisbehavin(BRPeerManager *manager, BRPeer *peer)
{
    for (size_t i = array_count(manager->peers); i > 0; i--) {
        if (BRPeerEq(&manager->peers[i - 1], peer)) array_rm(manager->peers, i - 1);
    }

    if (++manager->misbehavinCount >= 10) { // clear out stored peers so we get a fresh list from DNS for next connect
        manager->misbehavinCount = 0;
        array_clear(manager->peers);
    }

    BRPeerDisconnect(peer);
}

static void _BRPeerManagerSyncStopped(BRPeerManager *manager)
{
    manager->syncStartHeight = 0;

    if (manager->downloadPeer) {
        // don't cancel timeout if there's a pending tx publish callback
        for (size_t i = array_count(manager->publishedTx); i > 0; i--) {
            if (manager->publishedTx[i - 1].callback != NULL) return;
        }
    
        BRPeerScheduleDisconnect(manager->downloadPeer, -1); // cancel sync timeout
    }
}

// adds transaction to list of tx to be published, along with any unconfirmed inputs
static void _BRPeerManagerAddTxToPublishList(BRPeerManager *manager, BRTransaction *tx, void *info,
                                             void (*callback)(void *, int))
{
    if (tx && tx->blockHeight == TX_UNCONFIRMED) {
        for (size_t i = array_count(manager->publishedTx); i > 0; i--) {
            if (BRTransactionEq(manager->publishedTx[i - 1].tx, tx)) return;
        }
        
        array_add(manager->publishedTx, ((BRPublishedTx) { tx, info, callback }));
        array_add(manager->publishedTxHashes, tx->txHash);

        for (size_t i = 0; i < tx->inCount; i++) {
            _BRPeerManagerAddTxToPublishList(manager, BRWalletTransactionForHash(manager->wallet, tx->inputs[i].txHash),
                                             NULL, NULL);
        }
    }
}

static size_t _BRPeerManagerBlockLocators(BRPeerManager *manager, UInt256 locators[], size_t locatorsCount)
{
    // append 10 most recent block hashes, decending, then continue appending, doubling the step back each time,
    // finishing with the genesis block (top, -1, -2, -3, -4, -5, -6, -7, -8, -9, -11, -15, -23, -39, -71, -135, ..., 0)
    BRMerkleBlock *block = manager->lastBlock;
    int32_t step = 1, i = 0, j;
    
    while (block && block->height > 0) {
        if (locators && i < locatorsCount) locators[i] = block->blockHash;
        if (++i >= 10) step *= 2;
        
        for (j = 0; block && j < step; j++) {
            block = BRSetGet(manager->blocks, &block->prevBlock);
        }
    }
    
    if (locators && i < locatorsCount) locators[i] = GENESIS_BLOCK_HASH;
    return ++i;
}

static void _setApplyFreeBlock(void *info, void *block)
{
    BRMerkleBlockFree(block);
}

static void _BRPeerManagerLoadBloomFilter(BRPeerManager *manager, BRPeer *peer)
{
    // every time a new wallet address is added, the bloom filter has to be rebuilt, and each address is only used
    // for one transaction, so here we generate some spare addresses to avoid rebuilding the filter each time a
    // wallet transaction is encountered during the chain sync
    BRWalletUnusedAddrs(manager->wallet, NULL, SEQUENCE_GAP_LIMIT_EXTERNAL + 100, 0);
    BRWalletUnusedAddrs(manager->wallet, NULL, SEQUENCE_GAP_LIMIT_INTERNAL + 100, 1);

    BRSetApply(manager->orphans, NULL, _setApplyFreeBlock);
    BRSetClear(manager->orphans); // clear out orphans that may have been received on an old filter
    manager->lastOrphan = NULL;
    manager->filterUpdateHeight = manager->lastBlock->height;
    manager->fpRate = BLOOM_REDUCED_FALSEPOSITIVE_RATE;
    
    size_t addrsCount = BRWalletAllAddrs(manager->wallet, NULL, 0);
    BRAddress *addrs = malloc(addrsCount*sizeof(*addrs));
    size_t utxosCount = BRWalletUTXOs(manager->wallet, NULL, 0);
    BRUTXO *utxos = malloc(utxosCount*sizeof(*utxos));
    uint32_t blockHeight = (manager->lastBlock->height > 100) ? manager->lastBlock->height - 100 : 0;
    size_t txCount = BRWalletTxUnconfirmedBefore(manager->wallet, NULL, 0, blockHeight);
    BRTransaction **transactions = malloc(txCount*sizeof(*transactions));
    BRBloomFilter *filter;
    
    assert(addrs != NULL);
    assert(utxos != NULL);
    assert(transactions != NULL);
    addrsCount = BRWalletAllAddrs(manager->wallet, addrs, addrsCount);
    utxosCount = BRWalletUTXOs(manager->wallet, utxos, utxosCount);
    txCount = BRWalletTxUnconfirmedBefore(manager->wallet, transactions, txCount, blockHeight);
    filter = BRBloomFilterNew(manager->fpRate, addrsCount + utxosCount + txCount + 100, (uint32_t)BRPeerHash(peer),
                              BLOOM_UPDATE_ALL); // BUG: XXX txCount not the same as number of spent wallet outputs
    
    for (size_t i = 0; i < addrsCount; i++) { // add addresses to watch for tx receiveing money to the wallet
        UInt160 hash = UINT160_ZERO;
        
        BRAddressHash160(&hash, addrs[i].s);
        
        if (! UInt160IsZero(hash) && ! BRBloomFilterContainsData(filter, hash.u8, sizeof(hash))) {
            BRBloomFilterInsertData(filter, hash.u8, sizeof(hash));
        }
    }

    free(addrs);
        
    for (size_t i = 0; i < utxosCount; i++) { // add UTXOs to watch for tx sending money from the wallet
        uint8_t o[sizeof(UInt256) + sizeof(uint32_t)];
        
        UInt256Set(o, utxos[i].hash);
        UInt32SetLE(&o[sizeof(UInt256)], utxos[i].n);
        if (! BRBloomFilterContainsData(filter, o, sizeof(o))) BRBloomFilterInsertData(filter, o, sizeof(o));
    }
    
    free(utxos);
        
    for (size_t i = 0; i < txCount; i++) { // also add TXOs spent within the last 100 blocks
        for (size_t j = 0; j < transactions[i]->inCount; j++) {
            BRTxInput *input = &transactions[i]->inputs[j];
            BRTransaction *tx = BRWalletTransactionForHash(manager->wallet, input->txHash);
            uint8_t o[sizeof(UInt256) + sizeof(uint32_t)];
            
            if (tx && input->index < tx->outCount &&
                BRWalletContainsAddress(manager->wallet, tx->outputs[input->index].address)) {
                UInt256Set(o, input->txHash);
                UInt32SetLE(&o[sizeof(UInt256)], input->index);
                if (! BRBloomFilterContainsData(filter, o, sizeof(o))) BRBloomFilterInsertData(filter, o,sizeof(o));
            }
        }
    }
    
    free(transactions);
    if (manager->bloomFilter) BRBloomFilterFree(manager->bloomFilter);
    manager->bloomFilter = filter;
    // TODO: XXX if already synced, recursively add inputs of unconfirmed receives

    uint8_t data[BRBloomFilterSerialize(filter, NULL, 0)];
    size_t len = BRBloomFilterSerialize(filter, data, sizeof(data));
    
    BRPeerSendFilterload(peer, data, len);
}

static void _updateFilterRerequestDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    
    free(info);
    
    if (success) {
        pthread_mutex_lock(&manager->lock);

        if ((peer->flags & PEER_FLAG_NEEDSUPDATE) == 0) {
            UInt256 locators[_BRPeerManagerBlockLocators(manager, NULL, 0)];
            size_t count = _BRPeerManagerBlockLocators(manager, locators, sizeof(locators)/sizeof(*locators));
            
            BRPeerSendGetblocks(peer, locators, count, UINT256_ZERO);
        }

        pthread_mutex_unlock(&manager->lock);
    }
}

static void _updateFilterLoadDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    BRPeerCallbackInfo *peerInfo;

    free(info);
    
    if (success) {
        pthread_mutex_lock(&manager->lock);
        BRPeerSetNeedsFilterUpdate(peer, 0);
        peer->flags &= ~PEER_FLAG_NEEDSUPDATE;
        
        if (manager->lastBlock->height < manager->estimatedHeight) { // if syncing, rerequest blocks
            peerInfo = calloc(1, sizeof(*peerInfo));
            assert(peerInfo != NULL);
            peerInfo->peer = peer;
            peerInfo->manager = manager;
            BRPeerRerequestBlocks(manager->downloadPeer, manager->lastBlock->blockHash);
            BRPeerSendPing(manager->downloadPeer, peerInfo, _updateFilterRerequestDone);
        }
        else BRPeerSendMempool(peer, NULL, 0, NULL, NULL); // if not syncing, request mempool
        
        pthread_mutex_unlock(&manager->lock);
    }
}

static void _updateFilterPingDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    BRPeerCallbackInfo *peerInfo;
    
    if (success) {
        pthread_mutex_lock(&manager->lock);
        peer_log(peer, "updating filter with newly created wallet addresses");
        if (manager->bloomFilter) BRBloomFilterFree(manager->bloomFilter);
        manager->bloomFilter = NULL;

        if (manager->lastBlock->height < manager->estimatedHeight) { // if we're syncing, only update download peer
            if (manager->downloadPeer) {
                _BRPeerManagerLoadBloomFilter(manager, manager->downloadPeer);
                BRPeerSendPing(manager->downloadPeer, info, _updateFilterLoadDone); // wait for pong so filter is loaded
            }
            else free(info);
        }
        else {
            free(info);
            
            for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
                if (BRPeerConnectStatus(manager->connectedPeers[i - 1]) != BRPeerStatusConnected) continue;
                peerInfo = calloc(1, sizeof(*peerInfo));
                assert(peerInfo != NULL);
                peerInfo->peer = manager->connectedPeers[i - 1];
                peerInfo->manager = manager;
                _BRPeerManagerLoadBloomFilter(manager, peerInfo->peer);
                BRPeerSendPing(peerInfo->peer, peerInfo, _updateFilterLoadDone); // wait for pong so filter is loaded
            }
        }

         pthread_mutex_unlock(&manager->lock);
    }
    else free(info);
}

static void _BRPeerManagerUpdateFilter(BRPeerManager *manager)
{
    BRPeerCallbackInfo *info;

    if (manager->downloadPeer && (manager->downloadPeer->flags & PEER_FLAG_NEEDSUPDATE) == 0) {
        BRPeerSetNeedsFilterUpdate(manager->downloadPeer, 1);
        manager->downloadPeer->flags |= PEER_FLAG_NEEDSUPDATE;
        peer_log(manager->downloadPeer, "filter update needed, waiting for pong");
        info = calloc(1, sizeof(*info));
        assert(info != NULL);
        info->peer = manager->downloadPeer;
        info->manager = manager;
        // wait for pong so we're sure to include any tx already sent by the peer in the updated filter
        BRPeerSendPing(manager->downloadPeer, info, _updateFilterPingDone);
    }
}

static void _BRPeerManagerUpdateTx(BRPeerManager *manager, const UInt256 txHashes[], size_t txCount,
                                   uint32_t blockHeight, uint32_t timestamp)
{
    if (blockHeight != TX_UNCONFIRMED) { // remove confirmed tx from publish list and relay counts
        for (size_t i = 0; i < txCount; i++) {
            for (size_t j = array_count(manager->publishedTx); j > 0; j--) {
                BRTransaction *tx = manager->publishedTx[j - 1].tx;
                
                if (! UInt256Eq(txHashes[i], tx->txHash)) continue;
                array_rm(manager->publishedTx, j - 1);
                array_rm(manager->publishedTxHashes, j - 1);
                if (! BRWalletTransactionForHash(manager->wallet, tx->txHash)) BRTransactionFree(tx);
            }
            
            for (size_t j = array_count(manager->txRelays); j > 0; j--) {
                if (! UInt256Eq(txHashes[i], manager->txRelays[j - 1].txHash)) continue;
                array_free(manager->txRelays[j - 1].peers);
                array_rm(manager->txRelays, j - 1);
            }
        }
    }
    
    BRWalletUpdateTransactions(manager->wallet, txHashes, txCount, blockHeight, timestamp);
}

// unconfirmed transactions that aren't in the mempools of any of connected peers have likely dropped off the network
static void _requestUnrelayedTxGetdataDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    int isPublishing;
    size_t count = 0;

    free(info);
    pthread_mutex_lock(&manager->lock);
    if (success) peer->flags |= PEER_FLAG_SYNCED;
    
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
        peer = manager->connectedPeers[i - 1];
        if (BRPeerConnectStatus(peer) == BRPeerStatusConnected) count++;
        if ((peer->flags & PEER_FLAG_SYNCED) != 0) continue;
        count = 0;
        break;
    }

    // don't remove transactions until we're connected to maxConnectCount peers, and all peers have finished
    // relaying their mempools
    if (count >= manager->maxConnectCount) {
        size_t txCount = BRWalletTxUnconfirmedBefore(manager->wallet, NULL, 0, TX_UNCONFIRMED);
        BRTransaction *tx[(txCount < 10000) ? txCount : 10000];
        
        txCount = BRWalletTxUnconfirmedBefore(manager->wallet, tx, sizeof(tx)/sizeof(*tx), TX_UNCONFIRMED);

        for (size_t i = 0; i < txCount; i++) {
            isPublishing = 0;
            
            for (size_t j = array_count(manager->publishedTx); ! isPublishing && j > 0; j--) {
                if (BRTransactionEq(manager->publishedTx[j - 1].tx, tx[i]) &&
                    manager->publishedTx[j - 1].callback != NULL) isPublishing = 1;
            }
            
            if (! isPublishing && _BRTxPeerListCount(manager->txRelays, tx[i]->txHash) == 0 &&
                _BRTxPeerListCount(manager->txRequests, tx[i]->txHash) == 0) {
                BRWalletRemoveTransaction(manager->wallet, tx[i]->txHash);
            }
            else if (! isPublishing && _BRTxPeerListCount(manager->txRelays, tx[i]->txHash) < manager->maxConnectCount){
                // set timestamp 0 to mark as unverified
                _BRPeerManagerUpdateTx(manager, &tx[i]->txHash, 1, TX_UNCONFIRMED, 0);
            }
        }
    }

    pthread_mutex_unlock(&manager->lock);
}

static void _BRPeerManagerRequestUnrelayedTx(BRPeerManager *manager, BRPeer *peer)
{
    BRPeerCallbackInfo *info;
    size_t hashCount = 0, txCount = BRWalletTxUnconfirmedBefore(manager->wallet, NULL, 0, TX_UNCONFIRMED);
    BRTransaction *tx[txCount];
    UInt256 txHashes[txCount];
    
    txCount = BRWalletTxUnconfirmedBefore(manager->wallet, tx, txCount, TX_UNCONFIRMED);
    
    for (size_t i = 0; i < txCount; i++) {
        if (! _BRTxPeerListHasPeer(manager->txRelays, tx[i]->txHash, peer) &&
            ! _BRTxPeerListHasPeer(manager->txRequests, tx[i]->txHash, peer)) {
            txHashes[hashCount++] = tx[i]->txHash;
            _BRTxPeerListAddPeer(&manager->txRequests, tx[i]->txHash, peer);
        }
    }

    if (hashCount > 0) {
        BRPeerSendGetdata(peer, txHashes, hashCount, NULL, 0);
    
        if ((peer->flags & PEER_FLAG_SYNCED) == 0) {
            info = calloc(1, sizeof(*info));
            assert(info != NULL);
            info->peer = peer;
            info->manager = manager;
            BRPeerSendPing(peer, info, _requestUnrelayedTxGetdataDone);
        }
    }
    else peer->flags |= PEER_FLAG_SYNCED;
}

static void _BRPeerManagerPublishPendingTx(BRPeerManager *manager, BRPeer *peer)
{
    for (size_t i = array_count(manager->publishedTx); i > 0; i--) {
        if (manager->publishedTx[i - 1].callback == NULL) continue;
        BRPeerScheduleDisconnect(peer, PROTOCOL_TIMEOUT); // schedule publish timeout
        break;
    }
    
    BRPeerSendInv(peer, manager->publishedTxHashes, array_count(manager->publishedTxHashes));
}

static void _mempoolDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    int syncFinished = 0;
    
    free(info);
    
    if (success) {
        peer_log(peer, "mempool request finished");
        pthread_mutex_lock(&manager->lock);
        if (manager->syncStartHeight > 0) {
            peer_log(peer, "sync succeeded");
            syncFinished = 1;
            _BRPeerManagerSyncStopped(manager);
        }

        _BRPeerManagerRequestUnrelayedTx(manager, peer);
        BRPeerSendGetaddr(peer); // request a list of other bitcoin peers
        pthread_mutex_unlock(&manager->lock);
        if (manager->txStatusUpdate) manager->txStatusUpdate(manager->info);
        if (syncFinished && manager->syncStopped) manager->syncStopped(manager->info, 0);
    }
    else peer_log(peer, "mempool request failed");
}

static void _loadBloomFilterDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;

    pthread_mutex_lock(&manager->lock);
    
    if (success) {
        BRPeerSendMempool(peer, manager->publishedTxHashes, array_count(manager->publishedTxHashes), info,
                          _mempoolDone);
        pthread_mutex_unlock(&manager->lock);
    }
    else {
        free(info);
        
        if (peer == manager->downloadPeer) {
            peer_log(peer, "sync succeeded");
            _BRPeerManagerSyncStopped(manager);
            pthread_mutex_unlock(&manager->lock);
            if (manager->syncStopped) manager->syncStopped(manager->info, 0);
        }
        else pthread_mutex_unlock(&manager->lock);
    }
}

static void _BRPeerManagerLoadMempools(BRPeerManager *manager)
{
    // after syncing, load filters and get mempools from other peers
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
        BRPeer *peer = manager->connectedPeers[i - 1];
        BRPeerCallbackInfo *info;

        if (BRPeerConnectStatus(peer) != BRPeerStatusConnected) continue;
        info = calloc(1, sizeof(*info));
        assert(info != NULL);
        info->peer = peer;
        info->manager = manager;
        
        if (peer != manager->downloadPeer || manager->fpRate > BLOOM_REDUCED_FALSEPOSITIVE_RATE*5.0) {
            _BRPeerManagerLoadBloomFilter(manager, peer);
            _BRPeerManagerPublishPendingTx(manager, peer);
            BRPeerSendPing(peer, info, _loadBloomFilterDone); // load mempool after updating bloomfilter
        }
        else BRPeerSendMempool(peer, manager->publishedTxHashes, array_count(manager->publishedTxHashes), info,
                               _mempoolDone);
    }
}

// returns a UINT128_ZERO terminated array of addresses for hostname that must be freed, or NULL if lookup failed
static UInt128 *_addressLookup(const char *hostname)
{
    struct addrinfo *servinfo, *p;
    UInt128 *addrList = NULL;
    size_t count = 0, i = 0;
    
    if (getaddrinfo(hostname, NULL, NULL, &servinfo) == 0) {
        for (p = servinfo; p != NULL; p = p->ai_next) count++;
        if (count > 0) addrList = calloc(count + 1, sizeof(*addrList));
        assert(addrList != NULL || count == 0);
        
        for (p = servinfo; p != NULL; p = p->ai_next) {
            if (p->ai_family == AF_INET) {
                addrList[i].u16[5] = 0xffff;
                addrList[i].u32[3] = ((struct sockaddr_in *)p->ai_addr)->sin_addr.s_addr;
                i++;
            }
            else if (p->ai_family == AF_INET6) {
                addrList[i++] = *(UInt128 *)&((struct sockaddr_in6 *)p->ai_addr)->sin6_addr;
            }
        }
        
        freeaddrinfo(servinfo);
    }
    
    return addrList;
}

static void *_findPeersThreadRoutine(void *arg)
{
    BRPeerManager *manager = ((BRFindPeersInfo *)arg)->manager;
    uint64_t services = ((BRFindPeersInfo *)arg)->services;
    UInt128 *addrList, *addr;
    time_t now = time(NULL), age;
    
    pthread_cleanup_push(manager->threadCleanup, manager->info);
    addrList = _addressLookup(((BRFindPeersInfo *)arg)->hostname);
    free(arg);
    pthread_mutex_lock(&manager->lock);
    
    for (addr = addrList; addr && ! UInt128IsZero(*addr); addr++) {
        age = 24*60*60 + BRRand(2*24*60*60); // add between 1 and 3 days
        array_add(manager->peers, ((BRPeer) { *addr, STANDARD_PORT, services, now - age, 0 }));
    }

    manager->dnsThreadCount--;
    pthread_mutex_unlock(&manager->lock);
    if (addrList) free(addrList);
    pthread_cleanup_pop(1);
    return NULL;
}

// DNS peer discovery
static void _BRPeerManagerFindPeers(BRPeerManager *manager)
{
    static const uint64_t services = SERVICES_NODE_NETWORK | SERVICES_NODE_BLOOM;
    time_t now = time(NULL);
    struct timespec ts;
    pthread_t thread;
    pthread_attr_t attr;
    UInt128 *addr, *addrList;
    BRFindPeersInfo *info;
    
    if (! UInt128IsZero(manager->fixedPeer.address)) {
        array_set_count(manager->peers, 1);
        manager->peers[0] = manager->fixedPeer;
        manager->peers[0].services = services;
        manager->peers[0].timestamp = now;
    }
    else {
        for (size_t i = 1; i < DNS_SEEDS_COUNT; i++) {
            info = calloc(1, sizeof(BRFindPeersInfo));
            assert(info != NULL);
            info->manager = manager;
            info->hostname = dns_seeds[i];
            info->services = services;
            if (pthread_attr_init(&attr) == 0 && pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0 &&
                pthread_create(&thread, &attr, _findPeersThreadRoutine, info) == 0) manager->dnsThreadCount++;
        }

        for (addr = addrList = _addressLookup(dns_seeds[0]); addr && ! UInt128IsZero(*addr); addr++) {
            array_add(manager->peers, ((BRPeer) { *addr, STANDARD_PORT, services, now, 0 }));
        }

        if (addrList) free(addrList);
        ts.tv_sec = 0;
        ts.tv_nsec = 1;

        do {
            pthread_mutex_unlock(&manager->lock);
            nanosleep(&ts, NULL); // pthread_yield() isn't POSIX standard :(
            pthread_mutex_lock(&manager->lock);
        } while (manager->dnsThreadCount > 0 && array_count(manager->peers) < PEER_MAX_CONNECTIONS);
    
        qsort(manager->peers, array_count(manager->peers), sizeof(*manager->peers), _peerTimestampCompare);
    }
}

static void _peerConnected(void *info)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    BRPeerCallbackInfo *peerInfo;
    time_t now = time(NULL);
    
    pthread_mutex_lock(&manager->lock);
    if (peer->timestamp > now + 2*60*60 || peer->timestamp < now - 2*60*60) peer->timestamp = now; // sanity check
    
    // TODO: XXX does this work with 0.11 pruned nodes?
    if (! (peer->services & SERVICES_NODE_NETWORK)) {
        peer_log(peer, "node doesn't carry full blocks");
        BRPeerDisconnect(peer);
    }
    else if (BRPeerLastBlock(peer) + 10 < manager->lastBlock->height) {
        peer_log(peer, "node isn't synced");
        BRPeerDisconnect(peer);
    }
    else if ((peer->services & SERVICES_NODE_BCASH) == SERVICES_NODE_BCASH) {
        peer_log(peer, "b-cash nodes not supported");
        BRPeerDisconnect(peer);
    }
    else if (BRPeerVersion(peer) >= 70011 && ! (peer->services & SERVICES_NODE_BLOOM)) {
        peer_log(peer, "node doesn't support SPV mode");
        BRPeerDisconnect(peer);
    }
    else if (manager->downloadPeer && // check if we should stick with the existing download peer
             (BRPeerLastBlock(manager->downloadPeer) >= BRPeerLastBlock(peer) ||
              manager->lastBlock->height >= BRPeerLastBlock(peer))) {
        if (manager->lastBlock->height >= BRPeerLastBlock(peer)) { // only load bloom filter if we're done syncing
            manager->connectFailureCount = 0; // also reset connect failure count if we're already synced
            _BRPeerManagerLoadBloomFilter(manager, peer);
            _BRPeerManagerPublishPendingTx(manager, peer);
            peerInfo = calloc(1, sizeof(*peerInfo));
            assert(peerInfo != NULL);
            peerInfo->peer = peer;
            peerInfo->manager = manager;
            BRPeerSendPing(peer, peerInfo, _loadBloomFilterDone);
        }
    }
    else { // select the peer with the lowest ping time to download the chain from if we're behind
        // BUG: XXX a malicious peer can report a higher lastblock to make us select them as the download peer, if
        // two peers agree on lastblock, use one of those two instead
        for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
            BRPeer *p = manager->connectedPeers[i - 1];
            
            if (BRPeerConnectStatus(p) != BRPeerStatusConnected) continue;
            if ((BRPeerPingTime(p) < BRPeerPingTime(peer) && BRPeerLastBlock(p) >= BRPeerLastBlock(peer)) ||
                BRPeerLastBlock(p) > BRPeerLastBlock(peer)) peer = p;
        }
        
        if (manager->downloadPeer) BRPeerDisconnect(manager->downloadPeer);
        manager->downloadPeer = peer;
        manager->isConnected = 1;
        manager->estimatedHeight = BRPeerLastBlock(peer);
        _BRPeerManagerLoadBloomFilter(manager, peer);
        BRPeerSetCurrentBlockHeight(peer, manager->lastBlock->height);
        _BRPeerManagerPublishPendingTx(manager, peer);
            
        if (manager->lastBlock->height < BRPeerLastBlock(peer)) { // start blockchain sync
            UInt256 locators[_BRPeerManagerBlockLocators(manager, NULL, 0)];
            size_t count = _BRPeerManagerBlockLocators(manager, locators, sizeof(locators)/sizeof(*locators));
            
            BRPeerScheduleDisconnect(peer, PROTOCOL_TIMEOUT); // schedule sync timeout

            // request just block headers up to a week before earliestKeyTime, and then merkleblocks after that
            // we do not reset connect failure count yet incase this request times out
            if (manager->lastBlock->timestamp + 7*24*60*60 >= manager->earliestKeyTime) {
                BRPeerSendGetblocks(peer, locators, count, UINT256_ZERO);
            }
            else BRPeerSendGetheaders(peer, locators, count, UINT256_ZERO);
        }
        else { // we're already synced
            manager->connectFailureCount = 0; // reset connect failure count
            _BRPeerManagerLoadMempools(manager);
        }
    }

    pthread_mutex_unlock(&manager->lock);
}

static void _peerDisconnected(void *info, int error)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    BRTxPeerList *peerList;
    int willSave = 0, willReconnect = 0, txError = 0;
    size_t txCount = 0;
    
    //free(info);
    pthread_mutex_lock(&manager->lock);

    void *txInfo[array_count(manager->publishedTx)];
    void (*txCallback[array_count(manager->publishedTx)])(void *, int);
    
    if (error == EPROTO) { // if it's protocol error, the peer isn't following standard policy
        _BRPeerManagerPeerMisbehavin(manager, peer);
    }
    else if (error) { // timeout or some non-protocol related network error
        for (size_t i = array_count(manager->peers); i > 0; i--) {
            if (BRPeerEq(&manager->peers[i - 1], peer)) array_rm(manager->peers, i - 1);
        }
        
        manager->connectFailureCount++;
        
        // if it's a timeout and there's pending tx publish callbacks, the tx publish timed out
        // BUG: XXX what if it's a connect timeout and not a publish timeout?
        if (error == ETIMEDOUT && (peer != manager->downloadPeer || manager->syncStartHeight == 0 ||
                                   array_count(manager->connectedPeers) == 1)) txError = ETIMEDOUT;
    }
    
    for (size_t i = array_count(manager->txRelays); i > 0; i--) {
        peerList = &manager->txRelays[i - 1];

        for (size_t j = array_count(peerList->peers); j > 0; j--) {
            if (BRPeerEq(&peerList->peers[j - 1], peer)) array_rm(peerList->peers, j - 1);
        }
    }

    if (peer == manager->downloadPeer) { // download peer disconnected
        manager->isConnected = 0;
        manager->downloadPeer = NULL;
        if (manager->connectFailureCount > MAX_CONNECT_FAILURES) manager->connectFailureCount = MAX_CONNECT_FAILURES;
    }

    if (! manager->isConnected && manager->connectFailureCount == MAX_CONNECT_FAILURES) {
        _BRPeerManagerSyncStopped(manager);
        
        // clear out stored peers so we get a fresh list from DNS on next connect attempt
        array_clear(manager->peers);
        txError = ENOTCONN; // trigger any pending tx publish callbacks
        willSave = 1;
        peer_log(peer, "sync failed");
    }
    else if (manager->connectFailureCount < MAX_CONNECT_FAILURES) willReconnect = 1;
    
    if (txError) {
        for (size_t i = array_count(manager->publishedTx); i > 0; i--) {
            if (manager->publishedTx[i - 1].callback == NULL) continue;
            peer_log(peer, "transaction canceled: %s", strerror(txError));
            txInfo[txCount] = manager->publishedTx[i - 1].info;
            txCallback[txCount] = manager->publishedTx[i - 1].callback;
            txCount++;
            BRTransactionFree(manager->publishedTx[i - 1].tx);
            array_rm(manager->publishedTxHashes, i - 1);
            array_rm(manager->publishedTx, i - 1);
        }
    }
    
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
        if (manager->connectedPeers[i - 1] != peer) continue;
        array_rm(manager->connectedPeers, i - 1);
        break;
    }

    BRPeerFree(peer);
    pthread_mutex_unlock(&manager->lock);
    
    for (size_t i = 0; i < txCount; i++) {
        txCallback[i](txInfo[i], txError);
    }
    
    if (willSave && manager->savePeers) manager->savePeers(manager->info, 1, NULL, 0);
    if (willSave && manager->syncStopped) manager->syncStopped(manager->info, error);
    if (willReconnect) BRPeerManagerConnect(manager); // try connecting to another peer
    if (manager->txStatusUpdate) manager->txStatusUpdate(manager->info);
}

static void _peerRelayedPeers(void *info, const BRPeer peers[], size_t peersCount)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    time_t now = time(NULL);

    pthread_mutex_lock(&manager->lock);
    peer_log(peer, "relayed %zu peer(s)", peersCount);

    array_add_array(manager->peers, peers, peersCount);
    qsort(manager->peers, array_count(manager->peers), sizeof(*manager->peers), _peerTimestampCompare);

    // limit total to 2500 peers
    if (array_count(manager->peers) > 2500) array_set_count(manager->peers, 2500);
    peersCount = array_count(manager->peers);
    
    // remove peers more than 3 hours old, or until there are only 1000 left
    while (peersCount > 1000 && manager->peers[peersCount - 1].timestamp + 3*60*60 < now) peersCount--;
    array_set_count(manager->peers, peersCount);
    
    BRPeer save[peersCount];

    for (size_t i = 0; i < peersCount; i++) save[i] = manager->peers[i];
    pthread_mutex_unlock(&manager->lock);
    
    // peer relaying is complete when we receive <1000
    if (peersCount > 1 && peersCount < 1000 &&
        manager->savePeers) manager->savePeers(manager->info, 1, save, peersCount);
}

static void _peerRelayedTx(void *info, BRTransaction *tx)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    void *txInfo = NULL;
    void (*txCallback)(void *, int) = NULL;
    int isWalletTx = 0, hasPendingCallbacks = 0;
    size_t relayCount = 0;
    
    pthread_mutex_lock(&manager->lock);
    peer_log(peer, "relayed tx: %s", u256_hex_encode(tx->txHash));
    
    for (size_t i = array_count(manager->publishedTx); i > 0; i--) { // see if tx is in list of published tx
        if (UInt256Eq(manager->publishedTxHashes[i - 1], tx->txHash)) {
            txInfo = manager->publishedTx[i - 1].info;
            txCallback = manager->publishedTx[i - 1].callback;
            manager->publishedTx[i - 1].info = NULL;
            manager->publishedTx[i - 1].callback = NULL;
            relayCount = _BRTxPeerListAddPeer(&manager->txRelays, tx->txHash, peer);
        }
        else if (manager->publishedTx[i - 1].callback != NULL) hasPendingCallbacks = 1;
    }

    // cancel tx publish timeout if no publish callbacks are pending, and syncing is done or this is not downloadPeer
    if (! hasPendingCallbacks && (manager->syncStartHeight == 0 || peer != manager->downloadPeer)) {
        BRPeerScheduleDisconnect(peer, -1); // cancel publish tx timeout
    }

    if (manager->syncStartHeight == 0 || BRWalletContainsTransaction(manager->wallet, tx)) {
        isWalletTx = BRWalletRegisterTransaction(manager->wallet, tx);
        if (isWalletTx) tx = BRWalletTransactionForHash(manager->wallet, tx->txHash);
    }
    else {
        BRTransactionFree(tx);
        tx = NULL;
    }
    
    if (tx && isWalletTx) {
        // reschedule sync timeout
        if (manager->syncStartHeight > 0 && peer == manager->downloadPeer) {
            BRPeerScheduleDisconnect(peer, PROTOCOL_TIMEOUT);
        }
        
        if (BRWalletAmountSentByTx(manager->wallet, tx) > 0 && BRWalletTransactionIsValid(manager->wallet, tx)) {
            _BRPeerManagerAddTxToPublishList(manager, tx, NULL, NULL); // add valid send tx to mempool
        }

        // keep track of how many peers have or relay a tx, this indicates how likely the tx is to confirm
        // (we only need to track this after syncing is complete)
        if (manager->syncStartHeight == 0) relayCount = _BRTxPeerListAddPeer(&manager->txRelays, tx->txHash, peer);
        
        _BRTxPeerListRemovePeer(manager->txRequests, tx->txHash, peer);
        
        if (manager->bloomFilter != NULL) { // check if bloom filter is already being updated
            BRAddress addrs[SEQUENCE_GAP_LIMIT_EXTERNAL + SEQUENCE_GAP_LIMIT_INTERNAL];
            UInt160 hash;

            // the transaction likely consumed one or more wallet addresses, so check that at least the next <gap limit>
            // unused addresses are still matched by the bloom filter
            BRWalletUnusedAddrs(manager->wallet, addrs, SEQUENCE_GAP_LIMIT_EXTERNAL, 0);
            BRWalletUnusedAddrs(manager->wallet, addrs + SEQUENCE_GAP_LIMIT_EXTERNAL, SEQUENCE_GAP_LIMIT_INTERNAL, 1);

            for (size_t i = 0; i < SEQUENCE_GAP_LIMIT_EXTERNAL + SEQUENCE_GAP_LIMIT_INTERNAL; i++) {
                if (! BRAddressHash160(&hash, addrs[i].s) ||
                    BRBloomFilterContainsData(manager->bloomFilter, hash.u8, sizeof(hash))) continue;
                if (manager->bloomFilter) BRBloomFilterFree(manager->bloomFilter);
                manager->bloomFilter = NULL; // reset bloom filter so it's recreated with new wallet addresses
                _BRPeerManagerUpdateFilter(manager);
                break;
            }
        }
    }
    
    // set timestamp when tx is verified
    if (tx && relayCount >= manager->maxConnectCount && tx->blockHeight == TX_UNCONFIRMED && tx->timestamp == 0) {
        _BRPeerManagerUpdateTx(manager, &tx->txHash, 1, TX_UNCONFIRMED, (uint32_t)time(NULL));
    }
    
    pthread_mutex_unlock(&manager->lock);
    if (txCallback) txCallback(txInfo, 0);
}

static void _peerHasTx(void *info, UInt256 txHash)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    BRTransaction *tx;
    void *txInfo = NULL;
    void (*txCallback)(void *, int) = NULL;
    int isWalletTx = 0, hasPendingCallbacks = 0;
    size_t relayCount = 0;
    
    pthread_mutex_lock(&manager->lock);
    tx = BRWalletTransactionForHash(manager->wallet, txHash);
    peer_log(peer, "has tx: %s", u256_hex_encode(txHash));

    for (size_t i = array_count(manager->publishedTx); i > 0; i--) { // see if tx is in list of published tx
        if (UInt256Eq(manager->publishedTxHashes[i - 1], txHash)) {
            if (! tx) tx = manager->publishedTx[i - 1].tx;
            txInfo = manager->publishedTx[i - 1].info;
            txCallback = manager->publishedTx[i - 1].callback;
            manager->publishedTx[i - 1].info = NULL;
            manager->publishedTx[i - 1].callback = NULL;
            relayCount = _BRTxPeerListAddPeer(&manager->txRelays, txHash, peer);
        }
        else if (manager->publishedTx[i - 1].callback != NULL) hasPendingCallbacks = 1;
    }
    
    // cancel tx publish timeout if no publish callbacks are pending, and syncing is done or this is not downloadPeer
    if (! hasPendingCallbacks && (manager->syncStartHeight == 0 || peer != manager->downloadPeer)) {
        BRPeerScheduleDisconnect(peer, -1); // cancel publish tx timeout
    }

    if (tx) {
        isWalletTx = BRWalletRegisterTransaction(manager->wallet, tx);
        if (isWalletTx) tx = BRWalletTransactionForHash(manager->wallet, tx->txHash);

        // reschedule sync timeout
        if (manager->syncStartHeight > 0 && peer == manager->downloadPeer && isWalletTx) {
            BRPeerScheduleDisconnect(peer, PROTOCOL_TIMEOUT);
        }
        
        // keep track of how many peers have or relay a tx, this indicates how likely the tx is to confirm
        // (we only need to track this after syncing is complete)
        if (manager->syncStartHeight == 0) relayCount = _BRTxPeerListAddPeer(&manager->txRelays, txHash, peer);

        // set timestamp when tx is verified
        if (relayCount >= manager->maxConnectCount && tx && tx->blockHeight == TX_UNCONFIRMED && tx->timestamp == 0) {
            _BRPeerManagerUpdateTx(manager, &txHash, 1, TX_UNCONFIRMED, (uint32_t)time(NULL));
        }

        _BRTxPeerListRemovePeer(manager->txRequests, txHash, peer);
    }
    
    pthread_mutex_unlock(&manager->lock);
    if (txCallback) txCallback(txInfo, 0);
}

static void _peerRejectedTx(void *info, UInt256 txHash, uint8_t code)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    BRTransaction *tx, *t;

    pthread_mutex_lock(&manager->lock);
    peer_log(peer, "rejected tx: %s", u256_hex_encode(txHash));
    tx = BRWalletTransactionForHash(manager->wallet, txHash);
    _BRTxPeerListRemovePeer(manager->txRequests, txHash, peer);

    if (tx) {
        if (_BRTxPeerListRemovePeer(manager->txRelays, txHash, peer) && tx->blockHeight == TX_UNCONFIRMED) {
            // set timestamp 0 to mark tx as unverified
            _BRPeerManagerUpdateTx(manager, &txHash, 1, TX_UNCONFIRMED, 0);
        }

        // if we get rejected for any reason other than double-spend, the peer is likely misconfigured
        if (code != REJECT_SPENT && BRWalletAmountSentByTx(manager->wallet, tx) > 0) {
            for (size_t i = 0; i < tx->inCount; i++) { // check that all inputs are confirmed before dropping peer
                t = BRWalletTransactionForHash(manager->wallet, tx->inputs[i].txHash);
                if (! t || t->blockHeight != TX_UNCONFIRMED) continue;
                tx = NULL;
                break;
            }
            
            if (tx) _BRPeerManagerPeerMisbehavin(manager, peer);
        }
    }

    pthread_mutex_unlock(&manager->lock);
    if (manager->txStatusUpdate) manager->txStatusUpdate(manager->info);
}

static int _BRPeerManagerVerifyBlock(BRPeerManager *manager, BRMerkleBlock *block, BRMerkleBlock *prev, BRPeer *peer)
{
    uint32_t transitionTime = 0;
    int r = 1;
    
    // check if we hit a difficulty transition, and find previous transition time   TODO: fix difficulty interval for KGW,DGW
    if ((block->height % BLOCK_DIFFICULTY_INTERVAL) == 0) {
        BRMerkleBlock *b = block;
        UInt256 prevBlock;

        for (uint32_t i = 0; b && i < BLOCK_DIFFICULTY_INTERVAL; i++) {
            b = BRSetGet(manager->blocks, &b->prevBlock);
        }

        if (! b) {
            peer_log(peer, "missing previous difficulty tansition time, can't verify blockHash: %s",
                     u256_hex_encode(block->blockHash));
            r = 0;
        }
        else {
            transitionTime = b->timestamp;
            prevBlock = b->prevBlock;
        }
        
        while (b) { // free up some memory
            b = BRSetGet(manager->blocks, &prevBlock);
            if (b) prevBlock = b->prevBlock;

            if (b && (b->height % BLOCK_DIFFICULTY_INTERVAL) != 0) {
                BRSetRemove(manager->blocks, b);
                BRMerkleBlockFree(b);
            }
        }
    }

    // verify block difficulty
    if (r && ! BRMerkleBlockVerifyDifficulty(block, prev, transitionTime)) {
        peer_log(peer, "relayed block with invalid difficulty target %x, blockHash: %s", block->target,
                 u256_hex_encode(block->blockHash));
        r = 0;
    }
    
    if (r) {
        BRMerkleBlock *checkpoint = BRSetGet(manager->checkpoints, block);

        // verify blockchain checkpoints
        if (checkpoint && ! BRMerkleBlockEq(block, checkpoint)) {
            peer_log(peer, "relayed a block that differs from the checkpoint at height %"PRIu32", blockHash: %s, "
                     "expected: %s", block->height, u256_hex_encode(block->blockHash),
                     u256_hex_encode(checkpoint->blockHash));
            r = 0;
        }
    }

    return r;
}

static void _peerRelayedBlock(void *info, BRMerkleBlock *block)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    size_t txCount = BRMerkleBlockTxHashes(block, NULL, 0);
    UInt256 _txHashes[(sizeof(UInt256)*txCount <= 0x1000) ? txCount : 0],
            *txHashes = (sizeof(UInt256)*txCount <= 0x1000) ? _txHashes : malloc(txCount*sizeof(*txHashes));
    size_t i, j, fpCount = 0, saveCount = 0;
    BRMerkleBlock orphan, *b, *b2, *prev, *next = NULL;
    uint32_t txTime = 0;
    
    assert(txHashes != NULL);
    txCount = BRMerkleBlockTxHashes(block, txHashes, txCount);
    pthread_mutex_lock(&manager->lock);
    prev = BRSetGet(manager->blocks, &block->prevBlock);

    if (prev) {
        txTime = block->timestamp/2 + prev->timestamp/2;
        block->height = prev->height + 1;
    }
    
    // track the observed bloom filter false positive rate using a low pass filter to smooth out variance
    if (peer == manager->downloadPeer && block->totalTx > 0) {
        for (i = 0; i < txCount; i++) { // wallet tx are not false-positives
            if (! BRWalletTransactionForHash(manager->wallet, txHashes[i])) fpCount++;
        }
        
        // moving average number of tx-per-block
        manager->averageTxPerBlock = manager->averageTxPerBlock*0.999 + block->totalTx*0.001;
        
        // 1% low pass filter, also weights each block by total transactions, compared to the avarage
        manager->fpRate = manager->fpRate*(1.0 - 0.01*block->totalTx/manager->averageTxPerBlock) +
                          0.01*fpCount/manager->averageTxPerBlock;
        
        // false positive rate sanity check
        if (BRPeerConnectStatus(peer) == BRPeerStatusConnected &&
            manager->fpRate > BLOOM_DEFAULT_FALSEPOSITIVE_RATE*10.0) {
            peer_log(peer, "bloom filter false positive rate %f too high after %"PRIu32" blocks, disconnecting...",
                     manager->fpRate, manager->lastBlock->height + 1 - manager->filterUpdateHeight);
            BRPeerDisconnect(peer);
        }
        else if (manager->lastBlock->height + 500 < BRPeerLastBlock(peer) &&
                 manager->fpRate > BLOOM_REDUCED_FALSEPOSITIVE_RATE*10.0) {
            _BRPeerManagerUpdateFilter(manager); // rebuild bloom filter when it starts to degrade
        }
    }

    // ignore block headers that are newer than one week before earliestKeyTime (it's a header if it has 0 totalTx)
    if (block->totalTx == 0 && block->timestamp + 7*24*60*60 > manager->earliestKeyTime + 2*60*60) {
        BRMerkleBlockFree(block);
        block = NULL;
    }
    else if (manager->bloomFilter == NULL) { // ingore potentially incomplete blocks when a filter update is pending
        BRMerkleBlockFree(block);
        block = NULL;

        if (peer == manager->downloadPeer && manager->lastBlock->height < manager->estimatedHeight) {
            BRPeerScheduleDisconnect(peer, PROTOCOL_TIMEOUT); // reschedule sync timeout
            manager->connectFailureCount = 0; // reset failure count once we know our initial request didn't timeout
        }
    }
    else if (! prev) { // block is an orphan
        peer_log(peer, "relayed orphan block %s, previous %s, last block is %s, height %"PRIu32,
                 u256_hex_encode(block->blockHash), u256_hex_encode(block->prevBlock),
                 u256_hex_encode(manager->lastBlock->blockHash), manager->lastBlock->height);
        
        if (block->timestamp + 7*24*60*60 < time(NULL)) { // ignore orphans older than one week ago
            BRMerkleBlockFree(block);
            block = NULL;
        }
        else {
            // call getblocks, unless we already did with the previous block, or we're still syncing
            if (manager->lastBlock->height >= BRPeerLastBlock(peer) &&
                (! manager->lastOrphan || ! UInt256Eq(manager->lastOrphan->blockHash, block->prevBlock))) {
                UInt256 locators[_BRPeerManagerBlockLocators(manager, NULL, 0)];
                size_t locatorsCount = _BRPeerManagerBlockLocators(manager, locators,
                                                                   sizeof(locators)/sizeof(*locators));
                
                peer_log(peer, "calling getblocks");
                BRPeerSendGetblocks(peer, locators, locatorsCount, UINT256_ZERO);
            }
            
            BRSetAdd(manager->orphans, block); // BUG: limit total orphans to avoid memory exhaustion attack
            manager->lastOrphan = block;
        }
    }
    else if (! _BRPeerManagerVerifyBlock(manager, block, prev, peer)) { // block is invalid
        peer_log(peer, "relayed invalid block");
        BRMerkleBlockFree(block);
        block = NULL;
        _BRPeerManagerPeerMisbehavin(manager, peer);
    }
    else if (UInt256Eq(block->prevBlock, manager->lastBlock->blockHash)) { // new block extends main chain
        if ((block->height % 500) == 0 || txCount > 0 || block->height >= BRPeerLastBlock(peer)) {
            peer_log(peer, "adding block #%"PRIu32", false positive rate: %f", block->height, manager->fpRate);
        }
        
        BRSetAdd(manager->blocks, block);
        manager->lastBlock = block;
        if (txCount > 0) _BRPeerManagerUpdateTx(manager, txHashes, txCount, block->height, txTime);
        if (manager->downloadPeer) BRPeerSetCurrentBlockHeight(manager->downloadPeer, block->height);
            
        if (block->height < manager->estimatedHeight && peer == manager->downloadPeer) {
            BRPeerScheduleDisconnect(peer, PROTOCOL_TIMEOUT); // reschedule sync timeout
            manager->connectFailureCount = 0; // reset failure count once we know our initial request didn't timeout
        }
        
        if ((block->height % BLOCK_DIFFICULTY_INTERVAL) == 0) saveCount = 1; // save transition block immediately
        
        if (block->height == manager->estimatedHeight) { // chain download is complete
            saveCount = (block->height % BLOCK_DIFFICULTY_INTERVAL) + BLOCK_DIFFICULTY_INTERVAL + 1;
            _BRPeerManagerLoadMempools(manager);
        }
    }
    else if (BRSetContains(manager->blocks, block)) { // we already have the block (or at least the header)
        if ((block->height % 500) == 0 || txCount > 0 || block->height >= BRPeerLastBlock(peer)) {
            peer_log(peer, "relayed existing block #%"PRIu32, block->height);
        }
        
        b = manager->lastBlock;
        while (b && b->height > block->height) b = BRSetGet(manager->blocks, &b->prevBlock); // is block in main chain?
        
        if (BRMerkleBlockEq(b, block)) { // if it's not on a fork, set block heights for its transactions
            if (txCount > 0) _BRPeerManagerUpdateTx(manager, txHashes, txCount, block->height, txTime);
            if (block->height == manager->lastBlock->height) manager->lastBlock = block;
        }
        
        b = BRSetAdd(manager->blocks, block);

        if (b != block) {
            if (BRSetGet(manager->orphans, b) == b) BRSetRemove(manager->orphans, b);
            if (manager->lastOrphan == b) manager->lastOrphan = NULL;
            BRMerkleBlockFree(b);
        }
    }
    else if (manager->lastBlock->height < BRPeerLastBlock(peer) &&
             block->height > manager->lastBlock->height + 1) { // special case, new block mined durring rescan
        peer_log(peer, "marking new block #%"PRIu32" as orphan until rescan completes", block->height);
        BRSetAdd(manager->orphans, block); // mark as orphan til we're caught up
        manager->lastOrphan = block;
    }
    else if (block->height <= checkpoint_array[CHECKPOINT_COUNT - 1].height) { // fork is older than last checkpoint
        peer_log(peer, "ignoring block on fork older than most recent checkpoint, block #%"PRIu32", hash: %s",
                 block->height, u256_hex_encode(block->blockHash));
        BRMerkleBlockFree(block);
        block = NULL;
    }
    else { // new block is on a fork
        peer_log(peer, "chain fork reached height %"PRIu32, block->height);
        BRSetAdd(manager->blocks, block);

        if (block->height > manager->lastBlock->height) { // check if fork is now longer than main chain
            b = block;
            b2 = manager->lastBlock;
            
            while (b && b2 && ! BRMerkleBlockEq(b, b2)) { // walk back to where the fork joins the main chain
                b = BRSetGet(manager->blocks, &b->prevBlock);
                if (b && b->height < b2->height) b2 = BRSetGet(manager->blocks, &b2->prevBlock);
            }
            
            peer_log(peer, "reorganizing chain from height %"PRIu32", new height is %"PRIu32, b->height, block->height);
        
            BRWalletSetTxUnconfirmedAfter(manager->wallet, b->height); // mark tx after the join point as unconfirmed

            b = block;
        
            while (b && b2 && b->height > b2->height) { // set transaction heights for new main chain
                size_t count = BRMerkleBlockTxHashes(b, NULL, 0);
                uint32_t height = b->height, timestamp = b->timestamp;
                
                if (count > txCount) {
                    txHashes = (txHashes != _txHashes) ? realloc(txHashes, count*sizeof(*txHashes)) :
                               malloc(count*sizeof(*txHashes));
                    assert(txHashes != NULL);
                    txCount = count;
                }
                
                count = BRMerkleBlockTxHashes(b, txHashes, count);
                b = BRSetGet(manager->blocks, &b->prevBlock);
                if (b) timestamp = timestamp/2 + b->timestamp/2;
                if (count > 0) BRWalletUpdateTransactions(manager->wallet, txHashes, count, height, timestamp);
            }
        
            manager->lastBlock = block;
            
            if (block->height == manager->estimatedHeight) { // chain download is complete
                saveCount = (block->height % BLOCK_DIFFICULTY_INTERVAL) + BLOCK_DIFFICULTY_INTERVAL + 1;
                _BRPeerManagerLoadMempools(manager);
            }
        }
    }
   
    if (txHashes != _txHashes) free(txHashes);
   
    if (block && block->height != BLOCK_UNKNOWN_HEIGHT) {
        if (block->height > manager->estimatedHeight) manager->estimatedHeight = block->height;
        
        // check if the next block was received as an orphan
        orphan.prevBlock = block->blockHash;
        next = BRSetRemove(manager->orphans, &orphan);
    }
    
    BRMerkleBlock *saveBlocks[saveCount];
    
    for (i = 0, b = block; b && i < saveCount; i++) {
        saveBlocks[i] = b;
        b = BRSetGet(manager->blocks, &b->prevBlock);
    }
    
    // make sure the set of blocks to be saved starts at a difficulty interval
    j = (i > 0) ? saveBlocks[i - 1]->height % BLOCK_DIFFICULTY_INTERVAL : 0;
    if (j > 0) i -= (i > BLOCK_DIFFICULTY_INTERVAL - j) ? BLOCK_DIFFICULTY_INTERVAL - j : i;
    assert(i == 0 || (saveBlocks[i - 1]->height % BLOCK_DIFFICULTY_INTERVAL) == 0);
    pthread_mutex_unlock(&manager->lock);
    if (i > 0 && manager->saveBlocks) manager->saveBlocks(manager->info, (i > 1 ? 1 : 0), saveBlocks, i);
    
    if (block && block->height != BLOCK_UNKNOWN_HEIGHT && block->height >= BRPeerLastBlock(peer) &&
        manager->txStatusUpdate) {
        manager->txStatusUpdate(manager->info); // notify that transaction confirmations may have changed
    }
    
    if (next) _peerRelayedBlock(info, next);
}

static void _peerDataNotfound(void *info, const UInt256 txHashes[], size_t txCount,
                             const UInt256 blockHashes[], size_t blockCount)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;

    pthread_mutex_lock(&manager->lock);

    for (size_t i = 0; i < txCount; i++) {
        _BRTxPeerListRemovePeer(manager->txRelays, txHashes[i], peer);
        _BRTxPeerListRemovePeer(manager->txRequests, txHashes[i], peer);
    }

    pthread_mutex_unlock(&manager->lock);
}

static void _peerSetFeePerKb(void *info, uint64_t feePerKb)
{
    BRPeer *p, *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    uint64_t maxFeePerKb = 0, secondFeePerKb = 0;
    
    pthread_mutex_lock(&manager->lock);
    
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) { // find second highest fee rate
        p = manager->connectedPeers[i - 1];
        if (BRPeerConnectStatus(p) != BRPeerStatusConnected) continue;
        if (BRPeerFeePerKb(p) > maxFeePerKb) secondFeePerKb = maxFeePerKb, maxFeePerKb = BRPeerFeePerKb(p);
    }
    
    if (secondFeePerKb*3/2 > DEFAULT_FEE_PER_KB && secondFeePerKb*3/2 <= MAX_FEE_PER_KB &&
        secondFeePerKb*3/2 > BRWalletFeePerKb(manager->wallet)) {
        peer_log(peer, "increasing feePerKb to %llu based on feefilter messages from peers", secondFeePerKb*3/2);
        BRWalletSetFeePerKb(manager->wallet, secondFeePerKb*3/2);
    }

    pthread_mutex_unlock(&manager->lock);
}

//static void _peerRequestedTxPingDone(void *info, int success)
//{
//    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
//    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
//    UInt256 txHash = ((BRPeerCallbackInfo *)info)->hash;
//
//    free(info);
//    pthread_mutex_lock(&manager->lock);
//
//    if (success && ! _BRTxPeerListHasPeer(manager->txRequests, txHash, peer)) {
//        _BRTxPeerListAddPeer(&manager->txRequests, txHash, peer);
//        BRPeerSendGetdata(peer, &txHash, 1, NULL, 0); // check if peer will relay the transaction back
//    }
//    
//    pthread_mutex_unlock(&manager->lock);
//}

static BRTransaction *_peerRequestedTx(void *info, UInt256 txHash)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
//    BRPeerCallbackInfo *pingInfo;
    BRTransaction *tx = NULL;
    void *txInfo = NULL;
    void (*txCallback)(void *, int) = NULL;
    int hasPendingCallbacks = 0, error = 0;

    pthread_mutex_lock(&manager->lock);

    for (size_t i = array_count(manager->publishedTx); i > 0; i--) {
        if (UInt256Eq(manager->publishedTxHashes[i - 1], txHash)) {
            tx = manager->publishedTx[i - 1].tx;
            txInfo = manager->publishedTx[i - 1].info;
            txCallback = manager->publishedTx[i - 1].callback;
            manager->publishedTx[i - 1].info = NULL;
            manager->publishedTx[i - 1].callback = NULL;
        
            if (tx && ! BRWalletTransactionIsValid(manager->wallet, tx)) {
                error = EINVAL;
                array_rm(manager->publishedTx, i - 1);
                array_rm(manager->publishedTxHashes, i - 1);
                
                if (! BRWalletTransactionForHash(manager->wallet, txHash)) {
                    BRTransactionFree(tx);
                    tx = NULL;
                }
            }
        }
        else if (manager->publishedTx[i - 1].callback != NULL) hasPendingCallbacks = 1;
    }

    // cancel tx publish timeout if no publish callbacks are pending, and syncing is done or this is not downloadPeer
    if (! hasPendingCallbacks && (manager->syncStartHeight == 0 || peer != manager->downloadPeer)) {
        BRPeerScheduleDisconnect(peer, -1); // cancel publish tx timeout
    }

    if (tx && ! error) {
        _BRTxPeerListAddPeer(&manager->txRelays, txHash, peer);
        BRWalletRegisterTransaction(manager->wallet, tx);
    }
    
//    pingInfo = calloc(1, sizeof(*pingInfo));
//    assert(pingInfo != NULL);
//    pingInfo->peer = peer;
//    pingInfo->manager = manager;
//    pingInfo->hash = txHash;
//    BRPeerSendPing(peer, pingInfo, _peerRequestedTxPingDone);
    pthread_mutex_unlock(&manager->lock);
    if (txCallback) txCallback(txInfo, error);
    return tx;
}

static int _peerNetworkIsReachable(void *info)
{
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;

    return (manager->networkIsReachable) ? manager->networkIsReachable(manager->info) : 1;
}

static void _peerThreadCleanup(void *info)
{
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;

    free(info);
    if (manager->threadCleanup) manager->threadCleanup(manager->info);
}

static void _dummyThreadCleanup(void *info)
{
}

// returns a newly allocated BRPeerManager struct that must be freed by calling BRPeerManagerFree()
BRPeerManager *BRPeerManagerNew(BRWallet *wallet, uint32_t earliestKeyTime, BRMerkleBlock *blocks[], size_t blocksCount,
                                const BRPeer peers[], size_t peersCount)
{
    BRPeerManager *manager = calloc(1, sizeof(*manager));
    BRMerkleBlock orphan, *block = NULL;
    
    assert(manager != NULL);
    assert(wallet != NULL);
    assert(blocks != NULL || blocksCount == 0);
    assert(peers != NULL || peersCount == 0);
    manager->wallet = wallet;
    manager->earliestKeyTime = earliestKeyTime;
    manager->averageTxPerBlock = 1400;
    manager->maxConnectCount = PEER_MAX_CONNECTIONS;
    array_new(manager->peers, peersCount);
    if (peers) array_add_array(manager->peers, peers, peersCount);
    qsort(manager->peers, array_count(manager->peers), sizeof(*manager->peers), _peerTimestampCompare);
    array_new(manager->connectedPeers, PEER_MAX_CONNECTIONS);
    manager->blocks = BRSetNew(BRMerkleBlockHash, BRMerkleBlockEq, blocksCount);
    manager->orphans = BRSetNew(_BRPrevBlockHash, _BRPrevBlockEq, blocksCount); // orphans are indexed by prevBlock
    manager->checkpoints = BRSetNew(_BRBlockHeightHash, _BRBlockHeightEq, 100); // checkpoints are indexed by height

    for (size_t i = 0; i < CHECKPOINT_COUNT; i++) {
        block = BRMerkleBlockNew();
        block->height = checkpoint_array[i].height;
        block->blockHash = UInt256Reverse(u256_hex_decode(checkpoint_array[i].hash));
        block->timestamp = checkpoint_array[i].timestamp;
        block->target = checkpoint_array[i].target;
        BRSetAdd(manager->checkpoints, block);
        BRSetAdd(manager->blocks, block);
        if (i == 0 || block->timestamp + 7*24*60*60 < manager->earliestKeyTime) manager->lastBlock = block;
    }

    block = NULL;
    
    for (size_t i = 0; blocks && i < blocksCount; i++) {
        assert(blocks[i]->height != BLOCK_UNKNOWN_HEIGHT); // height must be saved/restored along with serialized block
        BRSetAdd(manager->orphans, blocks[i]);

        if ((blocks[i]->height % BLOCK_DIFFICULTY_INTERVAL) == 0 &&
            (! block || blocks[i]->height > block->height)) block = blocks[i]; // find last transition block
    }
    
    while (block) {
        BRSetAdd(manager->blocks, block);
        manager->lastBlock = block;
        orphan.prevBlock = block->prevBlock;
        BRSetRemove(manager->orphans, &orphan);
        orphan.prevBlock = block->blockHash;
        block = BRSetGet(manager->orphans, &orphan);
    }
    
    array_new(manager->txRelays, 10);
    array_new(manager->txRequests, 10);
    array_new(manager->publishedTx, 10);
    array_new(manager->publishedTxHashes, 10);
    pthread_mutex_init(&manager->lock, NULL);
    manager->threadCleanup = _dummyThreadCleanup;
    return manager;
}

// not thread-safe, set callbacks once before calling BRPeerManagerConnect()
// info is a void pointer that will be passed along with each callback call
// void syncStarted(void *) - called when blockchain syncing starts
// void syncStopped(void *, int) - called when blockchain syncing stops, error is an errno.h code
// void txStatusUpdate(void *) - called when transaction status may have changed such as when a new block arrives
// void saveBlocks(void *, int, BRMerkleBlock *[], size_t) - called when blocks should be saved to the persistent store
// - if replace is true, remove any previously saved blocks first
// void savePeers(void *, int, const BRPeer[], size_t) - called when peers should be saved to the persistent store
// - if replace is true, remove any previously saved peers first
// int networkIsReachable(void *) - must return true when networking is available, false otherwise
// void threadCleanup(void *) - called before a thread terminates to faciliate any needed cleanup
void BRPeerManagerSetCallbacks(BRPeerManager *manager, void *info,
                               void (*syncStarted)(void *info),
                               void (*syncStopped)(void *info, int error),
                               void (*txStatusUpdate)(void *info),
                               void (*saveBlocks)(void *info, int replace, BRMerkleBlock *blocks[], size_t blocksCount),
                               void (*savePeers)(void *info, int replace, const BRPeer peers[], size_t peersCount),
                               int (*networkIsReachable)(void *info),
                               void (*threadCleanup)(void *info))
{
    assert(manager != NULL);
    manager->info = info;
    manager->syncStarted = syncStarted;
    manager->syncStopped = syncStopped;
    manager->txStatusUpdate = txStatusUpdate;
    manager->saveBlocks = saveBlocks;
    manager->savePeers = savePeers;
    manager->networkIsReachable = networkIsReachable;
    manager->threadCleanup = (threadCleanup) ? threadCleanup : _dummyThreadCleanup;
}

// specifies a single fixed peer to use when connecting to the bitcoin network
// set address to UINT128_ZERO to revert to default behavior
void BRPeerManagerSetFixedPeer(BRPeerManager *manager, UInt128 address, uint16_t port)
{
    assert(manager != NULL);
    BRPeerManagerDisconnect(manager);
    pthread_mutex_lock(&manager->lock);
    manager->maxConnectCount = UInt128IsZero(address) ? PEER_MAX_CONNECTIONS : 1;
    manager->fixedPeer = ((BRPeer) { address, port, 0, 0, 0 });
    array_clear(manager->peers);
    pthread_mutex_unlock(&manager->lock);
}

// true if currently connected to at least one peer
int BRPeerManagerIsConnected(BRPeerManager *manager)
{
    int isConnected;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    isConnected = manager->isConnected;
    pthread_mutex_unlock(&manager->lock);
    return isConnected;
}

// connect to bitcoin peer-to-peer network (also call this whenever networkIsReachable() status changes)
void BRPeerManagerConnect(BRPeerManager *manager)
{
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    if (manager->connectFailureCount >= MAX_CONNECT_FAILURES) manager->connectFailureCount = 0; //this is a manual retry
    
    if ((! manager->downloadPeer || manager->lastBlock->height < manager->estimatedHeight) &&
        manager->syncStartHeight == 0) {
        manager->syncStartHeight = manager->lastBlock->height + 1;
        pthread_mutex_unlock(&manager->lock);
        if (manager->syncStarted) manager->syncStarted(manager->info);
        pthread_mutex_lock(&manager->lock);
    }
    
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
        BRPeer *p = manager->connectedPeers[i - 1];

        if (BRPeerConnectStatus(p) == BRPeerStatusConnecting) BRPeerConnect(p);
    }
    
    if (array_count(manager->connectedPeers) < manager->maxConnectCount) {
        time_t now = time(NULL);
        BRPeer *peers;

        if (array_count(manager->peers) < manager->maxConnectCount ||
            manager->peers[manager->maxConnectCount - 1].timestamp + 3*24*60*60 < now) {
            _BRPeerManagerFindPeers(manager);
        }
        
        array_new(peers, 100);
        array_add_array(peers, manager->peers,
                        (array_count(manager->peers) < 100) ? array_count(manager->peers) : 100);

        while (array_count(peers) > 0 && array_count(manager->connectedPeers) < manager->maxConnectCount) {
            size_t i = BRRand((uint32_t)array_count(peers)); // index of random peer
            BRPeerCallbackInfo *info;
            
            i = i*i/array_count(peers); // bias random peer selection toward peers with more recent timestamp
        
            for (size_t j = array_count(manager->connectedPeers); i != SIZE_MAX && j > 0; j--) {
                if (! BRPeerEq(&peers[i], manager->connectedPeers[j - 1])) continue;
                array_rm(peers, i); // already in connectedPeers
                i = SIZE_MAX;
            }
            
            if (i != SIZE_MAX) {
                info = calloc(1, sizeof(*info));
                assert(info != NULL);
                info->manager = manager;
                info->peer = BRPeerNew();
                *info->peer = peers[i];
                array_rm(peers, i);
                array_add(manager->connectedPeers, info->peer);
                BRPeerSetCallbacks(info->peer, info, _peerConnected, _peerDisconnected, _peerRelayedPeers,
                                   _peerRelayedTx, _peerHasTx, _peerRejectedTx, _peerRelayedBlock, _peerDataNotfound,
                                   _peerSetFeePerKb, _peerRequestedTx, _peerNetworkIsReachable, _peerThreadCleanup);
                BRPeerSetEarliestKeyTime(info->peer, manager->earliestKeyTime);
                BRPeerConnect(info->peer);
            }
        }

        array_free(peers);
    }
    
    if (array_count(manager->connectedPeers) == 0) {
        peer_log(&BR_PEER_NONE, "sync failed");
        _BRPeerManagerSyncStopped(manager);
        pthread_mutex_unlock(&manager->lock);
        if (manager->syncStopped) manager->syncStopped(manager->info, ENETUNREACH);
    }
    else pthread_mutex_unlock(&manager->lock);
}

void BRPeerManagerDisconnect(BRPeerManager *manager)
{
    struct timespec ts;
    size_t peerCount, dnsThreadCount;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    peerCount = array_count(manager->connectedPeers);
    dnsThreadCount = manager->dnsThreadCount;
    
    for (size_t i = peerCount; i > 0; i--) {
        manager->connectFailureCount = MAX_CONNECT_FAILURES; // prevent futher automatic reconnect attempts
        BRPeerDisconnect(manager->connectedPeers[i - 1]);
    }
    
    pthread_mutex_unlock(&manager->lock);
    ts.tv_sec = 0;
    ts.tv_nsec = 1;
    
    while (peerCount > 0 || dnsThreadCount > 0) {
        nanosleep(&ts, NULL); // pthread_yield() isn't POSIX standard :(
        pthread_mutex_lock(&manager->lock);
        peerCount = array_count(manager->connectedPeers);
        dnsThreadCount = manager->dnsThreadCount;
        pthread_mutex_unlock(&manager->lock);
    }
}

// rescans blocks and transactions after earliestKeyTime (a new random download peer is also selected due to the
// possibility that a malicious node might lie by omitting transactions that match the bloom filter)
void BRPeerManagerRescan(BRPeerManager *manager)
{
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    
    if (manager->isConnected) {
        // start the chain download from the most recent checkpoint that's at least a week older than earliestKeyTime
        for (size_t i = CHECKPOINT_COUNT; i > 0; i--) {
            if (i - 1 == 0 || checkpoint_array[i - 1].timestamp + 7*24*60*60 < manager->earliestKeyTime) {
                UInt256 hash = UInt256Reverse(u256_hex_decode(checkpoint_array[i - 1].hash));

                manager->lastBlock = BRSetGet(manager->blocks, &hash);
                break;
            }
        }
        
        if (manager->downloadPeer) { // disconnect the current download peer so a new random one will be selected
            for (size_t i = array_count(manager->peers); i > 0; i--) {
                if (BRPeerEq(&manager->peers[i - 1], manager->downloadPeer)) array_rm(manager->peers, i - 1);
            }
            
            BRPeerDisconnect(manager->downloadPeer);
        }

        manager->syncStartHeight = 0; // a syncStartHeight of 0 indicates that syncing hasn't started yet
        pthread_mutex_unlock(&manager->lock);
        BRPeerManagerConnect(manager);
    }
    else pthread_mutex_unlock(&manager->lock);
}

// the (unverified) best block height reported by connected peers
uint32_t BRPeerManagerEstimatedBlockHeight(BRPeerManager *manager)
{
    uint32_t height;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    height = (manager->lastBlock->height < manager->estimatedHeight) ? manager->estimatedHeight :
             manager->lastBlock->height;
    pthread_mutex_unlock(&manager->lock);
    return height;
}

// current proof-of-work verified best block height
uint32_t BRPeerManagerLastBlockHeight(BRPeerManager *manager)
{
    uint32_t height;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    height = manager->lastBlock->height;
    pthread_mutex_unlock(&manager->lock);
    return height;
}

// current proof-of-work verified best block timestamp (time interval since unix epoch)
uint32_t BRPeerManagerLastBlockTimestamp(BRPeerManager *manager)
{
    uint32_t timestamp;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    timestamp = manager->lastBlock->timestamp;
    pthread_mutex_unlock(&manager->lock);
    return timestamp;
}

// current network sync progress from 0 to 1
// startHeight is the block height of the most recent fully completed sync
double BRPeerManagerSyncProgress(BRPeerManager *manager, uint32_t startHeight)
{
    double progress;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    if (startHeight == 0) startHeight = manager->syncStartHeight;
    
    if (! manager->downloadPeer && manager->syncStartHeight == 0) {
        progress = 0.0;
    }
    else if (! manager->downloadPeer || manager->lastBlock->height < manager->estimatedHeight) {
        if (manager->lastBlock->height > startHeight && manager->estimatedHeight > startHeight) {
            progress = 0.1 + 0.9*(manager->lastBlock->height - startHeight)/(manager->estimatedHeight - startHeight);
        }
        else progress = 0.05;
    }
    else progress = 1.0;

    pthread_mutex_unlock(&manager->lock);
    return progress;
}

// returns the number of currently connected peers
size_t BRPeerManagerPeerCount(BRPeerManager *manager)
{
    size_t count = 0;
    
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) {
        if (BRPeerConnectStatus(manager->connectedPeers[i - 1]) == BRPeerStatusConnected) count++;
    }
    
    pthread_mutex_unlock(&manager->lock);
    return count;
}

// description of the peer most recently used to sync blockchain data
const char *BRPeerManagerDownloadPeerName(BRPeerManager *manager)
{
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);

    if (manager->downloadPeer) {
        sprintf(manager->downloadPeerName, "%s:%d", BRPeerHost(manager->downloadPeer), manager->downloadPeer->port);
    }
    else manager->downloadPeerName[0] = '\0';
    
    pthread_mutex_unlock(&manager->lock);
    return manager->downloadPeerName;
}

static void _publishTxInvDone(void *info, int success)
{
    BRPeer *peer = ((BRPeerCallbackInfo *)info)->peer;
    BRPeerManager *manager = ((BRPeerCallbackInfo *)info)->manager;
    
    free(info);
    pthread_mutex_lock(&manager->lock);
    _BRPeerManagerRequestUnrelayedTx(manager, peer);
    pthread_mutex_unlock(&manager->lock);
}

// publishes tx to bitcoin network (do not call BRTransactionFree() on tx afterward)
void BRPeerManagerPublishTx(BRPeerManager *manager, BRTransaction *tx, void *info,
                            void (*callback)(void *info, int error))
{
    assert(manager != NULL);
    assert(tx != NULL && BRTransactionIsSigned(tx));
    if (tx) pthread_mutex_lock(&manager->lock);
    
    if (tx && ! BRTransactionIsSigned(tx)) {
        pthread_mutex_unlock(&manager->lock);
        BRTransactionFree(tx);
        tx = NULL;
        if (callback) callback(info, EINVAL); // transaction not signed
    }
    else if (tx && ! manager->isConnected) {
        int connectFailureCount = manager->connectFailureCount;

        pthread_mutex_unlock(&manager->lock);

        if (connectFailureCount >= MAX_CONNECT_FAILURES ||
            (manager->networkIsReachable && ! manager->networkIsReachable(manager->info))) {
            BRTransactionFree(tx);
            tx = NULL;
            if (callback) callback(info, ENOTCONN); // not connected to bitcoin network
        }
        else pthread_mutex_lock(&manager->lock);
    }
    
    if (tx) {
        size_t i, count = 0;
        
        tx->timestamp = (uint32_t)time(NULL); // set timestamp to publish time
        _BRPeerManagerAddTxToPublishList(manager, tx, info, callback);

        for (i = array_count(manager->connectedPeers); i > 0; i--) {
            if (BRPeerConnectStatus(manager->connectedPeers[i - 1]) == BRPeerStatusConnected) count++;
        }

        for (i = array_count(manager->connectedPeers); i > 0; i--) {
            BRPeer *peer = manager->connectedPeers[i - 1];
            BRPeerCallbackInfo *peerInfo;

            if (BRPeerConnectStatus(peer) != BRPeerStatusConnected) continue;
            
            // instead of publishing to all peers, leave out downloadPeer to see if tx propogates/gets relayed back
            // TODO: XXX connect to a random peer with an empty or fake bloom filter just for publishing
            if (peer != manager->downloadPeer || count == 1) {
                _BRPeerManagerPublishPendingTx(manager, peer);
                peerInfo = calloc(1, sizeof(*peerInfo));
                assert(peerInfo != NULL);
                peerInfo->peer = peer;
                peerInfo->manager = manager;
                BRPeerSendPing(peer, peerInfo, _publishTxInvDone);
            }
        }

        pthread_mutex_unlock(&manager->lock);
    }
}

// number of connected peers that have relayed the given unconfirmed transaction
size_t BRPeerManagerRelayCount(BRPeerManager *manager, UInt256 txHash)
{
    size_t count = 0;

    assert(manager != NULL);
    assert(! UInt256IsZero(txHash));
    pthread_mutex_lock(&manager->lock);
    
    for (size_t i = array_count(manager->txRelays); i > 0; i--) {
        if (! UInt256Eq(manager->txRelays[i - 1].txHash, txHash)) continue;
        count = array_count(manager->txRelays[i - 1].peers);
        break;
    }
    
    pthread_mutex_unlock(&manager->lock);
    return count;
}

// frees memory allocated for manager
void BRPeerManagerFree(BRPeerManager *manager)
{
    assert(manager != NULL);
    pthread_mutex_lock(&manager->lock);
    array_free(manager->peers);
    for (size_t i = array_count(manager->connectedPeers); i > 0; i--) BRPeerFree(manager->connectedPeers[i - 1]);
    array_free(manager->connectedPeers);
    BRSetApply(manager->blocks, NULL, _setApplyFreeBlock);
    BRSetFree(manager->blocks);
    BRSetApply(manager->orphans, NULL, _setApplyFreeBlock);
    BRSetFree(manager->orphans);
    BRSetFree(manager->checkpoints);
    for (size_t i = array_count(manager->txRelays); i > 0; i--) free(manager->txRelays[i - 1].peers);
    array_free(manager->txRelays);
    for (size_t i = array_count(manager->txRequests); i > 0; i--) free(manager->txRequests[i - 1].peers);
    array_free(manager->txRequests);
    array_free(manager->publishedTx);
    array_free(manager->publishedTxHashes);
    pthread_mutex_unlock(&manager->lock);
    pthread_mutex_destroy(&manager->lock);
    free(manager);
}
